<!doctype html>
<html
  lang="sl-si" 
  data-theme-mode="auto"
  >
  <head><meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, shrink-to-fit=no"
/><title>
  Uvod v računalniški vid in razpoznavanje vzorcev | PrincessSarmica
</title>
<meta name="description" content="Notes of a delusional programmer"/><script>
  window.siteConfig = JSON.parse("{\"anchor_icon\":null,\"base\":\"https://example.org/\",\"clipboard\":{\"copyright\":{\"count\":50,\"enable\":false,\"license_type\":\"by-nc-sa\"},\"fail\":{\"en\":\"Copy failed (ﾟ⊿ﾟ)ﾂ\",\"ja\":\"コピー失敗 (ﾟ⊿ﾟ)ﾂ\",\"pt-br\":\"Falha ao copiar (ﾟ⊿ﾟ)ﾂ\",\"si\":\"Kopiranje ni uspelo (ﾟ⊿ﾟ)ﾂ\",\"zh-cn\":\"复制失败 (ﾟ⊿ﾟ)ﾂ\",\"zh-tw\":\"複製失敗 (ﾟ⊿ﾟ)ﾂ\"},\"success\":{\"en\":\"Copy successfully (*^▽^*)\",\"ja\":\"コピー成功 (*^▽^*)\",\"pt-br\":\"Copiado com sucesso (*^▽^*)\",\"si\":\"Kopiranje uspešno (*^▽^*)\",\"zh-cn\":\"复制成功 (*^▽^*)\",\"zh-tw\":\"複製成功 (*^▽^*)\"}},\"code_block\":{\"expand\":true},\"icon_font\":false,\"outdate\":{\"daysago\":180,\"enable\":false,\"message\":{\"en\":\"This article was last updated on {time}. Please note that the content may no longer be applicable.\",\"ja\":\"この記事は最終更新日：{time}。記載内容が現在有効でない可能性がありますのでご注意ください。\",\"pt-br\":\"Este artigo foi atualizado pela última vez em {time}. Observe que o conteúdo pode não ser mais aplicável.\",\"si\":\"Ta članek je bil nazadnje posodobljen {time}. Upoštevajte, da vsebina morda ni več veljavna.\",\"zh-cn\":\"本文最后更新于 {time}，请注意文中内容可能已不适用。\",\"zh-tw\":\"本文最後更新於 {time}，請注意文中內容可能已不適用。\"}}}");
  
</script>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
  rel="preload"
  as="style"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"
  media="print"
  onload="this.media='all'"
/>
<link
    rel="stylesheet"
    href="https://npm.webcache.cn/@fortawesome/fontawesome-free@7.1.0/css/regular.min.css"
    integrity="sha384-4qYppzjH8EiA&#43;cGdaubu2vL7Rk8WGiqCSj7oRuP1uwtFWkfKNHD20lPfcrbQc8dU" crossorigin="anonymous"/><link
    rel="stylesheet"
    href="https://npm.webcache.cn/@fortawesome/fontawesome-free@7.1.0/css/solid.min.css"
    integrity="sha384-wbMWab3UDSPm2kvIgVOn/d9KPTecgPU1&#43;Nb3zoQrm/oVu0EkPL6IaKinjbwW0rum" crossorigin="anonymous"/><link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/@fortawesome/fontawesome-free@7.1.0/css/brands.min.css"
    integrity="sha384-KTGeC2hIMzpeQakhsmzB9bZfhCD5xZZCgI1iZH6f/O457SxzlkzTQg/WXFNoi3ih" crossorigin="anonymous"
    onload="this.onload=null;this.rel='stylesheet'"
  /><link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/@fortawesome/fontawesome-free@7.1.0/css/v5-font-face.min.css"
    integrity="sha384-nJ1ThfldViXoLpJ6jlKcP2beas8BMbYq26SG9Hi8cH89bZi4RZ644v7helMCqJxd" crossorigin="anonymous"
    onload="this.onload=null;this.rel='stylesheet'"
  /><link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/@fortawesome/fontawesome-free@7.1.0/css/v4-font-face.min.css"
    integrity="sha384-UlkrhOIvZxJFd4MElSUp7ow6/RUeYKi/orfCZIRRiOENFuQPIAA3T3HjYfmBRhNq" crossorigin="anonymous"
    onload="this.onload=null;this.rel='stylesheet'"
  /><link rel="stylesheet" href="/css/loader.min.ac746e154f756f8220326eeb52a719f142ab038be5a8ddf30ea5ef15ef2356ea.css" /><meta property="og:type" content="website" />
  <meta property="og:title" content="Uvod v računalniški vid in razpoznavanje vzorcev | PrincessSarmica" />
  <meta
    property="og:description"
    content="Notes of a delusional programmer"
  />
  <meta property="og:url" content="https://example.org/post/urvrv/" />
  <meta
    property="og:site_name"
    content="Feri Notes"
  />
  <meta
    property="og:image"
    content="/"
  />
  <meta property="article:author" content="PrincessSarmica" />
  <meta property="article:published_time" content="2026-02-03T07:07:07&#43;01:00" />
  <meta property="article:modified_time" content="2026-02-03T07:07:07&#43;01:00" /><meta name="twitter:card" content="summary" />
  <meta name="twitter:image" content="/" />
<link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/main.min.f7dd5bb83029739f401f7acab8421b760b475014ed86804efc74ae778f5222b8.css" /><link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css"
    integrity="sha384-IfxC36XL/toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei&#43;Zx/1oA/0l8ysE" crossorigin="anonymous"
    onload="this.onload=null;this.rel='stylesheet'"
  /><link
    rel="preload"
    as="style"
    href="https://npm.webcache.cn/katex@0.16.24/dist/katex.min.css"
    integrity="sha384-tTgKLjMYmJr94v8qu2PE5MUGSMbyN2xiH266JUB3gpm8vnnJywd1dWSOEfrFz&#43;YI" crossorigin="anonymous"
    onload="this.onload=null;this.rel='stylesheet'"
  /><script
    src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js"
    
    
    
    
    integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script><link
    rel="stylesheet"
    href="https://npm.webcache.cn/@reimujs/aos@0.1.2/dist/aos.css"
    integrity="sha384-GMRP93c6Hkz9JVKGAuRR3nTS7M07RwPgTFenXiosjq2VbVgvdDNcz1g6Mkj8AONa" crossorigin="anonymous"/></head>
  <body><div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi rotate"><img src="/images/programmer-taichi.svg" alt="loading" /></div><div class="loading-word">Loading...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var loaderEl = document.getElementById('loader');
    var startLoading = () => {
      time = Date.now();
      loaderEl.classList.remove("loading");
    }
    var hideLoader = () => {
      document.body.style.overflow = 'auto';
      loader.classList.add('loading');
    };

    var endLoading = () => {
      if (!time) {
        hideLoader();
      } else {
        if (Date.now() - time > 500) {
          time = null;
          hideLoader();
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    loaderEl.addEventListener('click', endLoading);
  </script><div id="copy-tooltip"></div>
<div id="lang-tooltip">
This article does not have a corresponding language version
</div>
<div id="heatmap-tooltip"></div><div id="container">
      <div id="wrap"><div id="header-nav">
  <nav id="main-nav" aria-label="Primary navigation"><a class="main-nav-link-wrap" href="/"><div class='main-nav-icon icon '>&#xe3af;</div><span class="main-nav-link">Home</span>
      </a><a class="main-nav-link-wrap" href="/archives"><div class='main-nav-icon icon '>&#xf187;</div><span class="main-nav-link">Archives</span>
      </a><a class="main-nav-link-wrap" href="/about"><div class='main-nav-icon icon '>&#xf05a;</div><span class="main-nav-link">About</span>
      </a><a class="main-nav-link-wrap" href="/friend"><div class='main-nav-icon icon '>&#xf500;</div><span class="main-nav-link">Friend</span>
      </a><a id="main-nav-toggle" class="nav-icon" aria-label="Toggle navigation" role="button"></a>
  </nav>
  <nav id="sub-nav" aria-label="Secondary navigation"></nav></div>
<header id="header" aria-label="Site header"><picture></picture><img crossorigin="anonymous" fetchpriority="high" src="/images/banner.webp" alt="Uvod v računalniški vid in razpoznavanje vzorcev"><div id="header-outer">
    <div id="header-title"><span id="logo">
            <h1 data-aos="slide-up">Uvod v računalniški vid in razpoznavanje vzorcev</h1>
          </span><h2 id="subtitle-wrap" data-aos="slide-down"></h2></div>
  </div>
</header><div id="content"
          aria-label="Page content"
          class="sidebar-left"
            ><aside id="sidebar" aria-label="Sidebar"><div class="sidebar-wrapper-container sticky"><div class="sidebar-wrapper">
    <div
      class="sidebar-wrap"
      data-aos="fade-up"
    ><div class="sidebar-toc-sidebar"><h3 class="toc-title">Contents</h3>
<div class="sidebar-toc-wrapper toc-div-class">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#uvod-v-računalniški-vid">Uvod v računalniški vid</a>
      <ul>
        <li><a href="#osnovni-pojmi">Osnovni pojmi</a></li>
        <li><a href="#uporabljene-oznake">Uporabljene oznake</a></li>
        <li><a href="#operacije-nad-slikami">Operacije nad slikami</a></li>
      </ul>
    </li>
    <li><a href="#model-kamere-in-zajemanje-slik">Model kamere in zajemanje slik</a>
      <ul>
        <li><a href="#zajemanje-slik-s-kamerami-ccd">Zajemanje slik s kamerami CCD</a></li>
        <li><a href="#modeli-kamer">Modeli kamer</a></li>
        <li><a href="#parametri-kamere">Parametri kamere</a></li>
        <li><a href="#geometrijsko-kalibriranje-kamer">Geometrijsko kalibriranje kamer</a></li>
      </ul>
    </li>
    <li><a href="#predobdelava-slik">Predobdelava slik</a>
      <ul>
        <li><a href="#spreminajnje-kontrasta">Spreminajnje kontrasta</a></li>
        <li><a href="#lokalne-operacije-oz-filtriranje-slik">Lokalne operacije oz. filtriranje slik</a></li>
        <li><a href="#odstranjevanje-šuma-z-lokalnimi-operatorji">Odstranjevanje šuma z lokalnimi operatorji</a></li>
        <li><a href="#detektorji-robov">Detektorji robov</a></li>
      </ul>
    </li>
    <li><a href="#segmentacija-slik">Segmentacija slik</a>
      <ul>
        <li><a href="#pragovna-operacija">Pragovna operacija</a></li>
        <li><a href="#pragovna-operacija-na-sliki-robov">Pragovna operacija na sliki robov</a></li>
        <li><a href="#ujemanje-šablon">Ujemanje šablon</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div></div>
          <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img
    data-src="/avatar/../images/avatar/avatar.webp"
    data-sizes="auto"
    alt="PrincessSarmica"
    class="lazyload"
  />
  <div class="sidebar-author-name">PrincessSarmica</div>
  <div class="sidebar-description">Notes of a delusional programmer</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div><div class="sidebar-state-number">2</div>
  </div>
  <a class="sidebar-state-category" href="/categories/" aria-label="sidebar-state-category-link">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </a>
  <a class="sidebar-state-tag" href="/tags/" aria-label="sidebar-state-tag-link">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </a>
</div>
<div class="sidebar-social" ><div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/princesssarmica"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener nofollow noreferrer"
      ></a>
    </div></div><div class="sidebar-menu"><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="Home"
      ></a><div class='sidebar-menu-icon icon '>&#xe3af;</div><div class="sidebar-menu-link">Home</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="Archives"
      ></a><div class='sidebar-menu-icon icon '>&#xf187;</div><div class="sidebar-menu-link">Archives</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="About"
      ></a><div class='sidebar-menu-icon icon '>&#xf05a;</div><div class="sidebar-menu-link">About</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/friend"
        aria-label="Friend"
      ></a><div class='sidebar-menu-icon icon '>&#xf500;</div><div class="sidebar-menu-link">Friend</div>
    </div></div></div><div class="sidebar-btn-wrapper" style="position:static">
            <div class="sidebar-toc-btn current"></div>
            <div class="sidebar-common-btn"></div>
          </div></div>
  </div><div class="sidebar-widget"></div></div></aside>
<section id="main" aria-label="Main content"><article
  class="h-entry article"
  itemscope
  itemtype="https://schema.org/BlogPosting"
>
  <div
    class="article-inner"
    data-aos="fade-up"
  >
    <div class="article-meta"><div class="article-date">
  <span
    class="article-date-link icon-calendar"
    data-aos="zoom-in"
  >
    <time datetime="2026-02-03 07:07:07 &#43;0100 CET" itemprop="datePublished"
      >2026-02-03</time
    >
    <time style="display: none;" id="post-update-time"
      >2026-02-03</time
    >
  </span></div>
</div><div class="hr-line"></div><div class="e-content article-entry" itemprop="articleBody"><h2 id="uvod-v-računalniški-vid">
<a class="header-anchor" href="#uvod-v-ra%c4%8dunalni%c5%a1ki-vid"></a>
Uvod v računalniški vid
</h2><h3 id="osnovni-pojmi">
<a class="header-anchor" href="#osnovni-pojmi"></a>
Osnovni pojmi
</h3><h4 id="zvezna-in-diskretna-predstavitev-signalov">
<a class="header-anchor" href="#zvezna-in-diskretna-predstavitev-signalov"></a>
Zvezna in diskretna predstavitev signalov
</h4><p>Računalniki so diskretne naprave, saj temeljijo na obdelavi podatkov v obliki vrednosti 0 in 1. Zato zveznih signalov in slik ne moremo neposredno obdelovati, temveč jih moramo najprej pretvoriti v <strong>diskretno obliko</strong>.</p>
<p>Zvezni govor (npr. ko profesor govori) je <strong>zvezni enodimenzionalni signal</strong>. Modeliramo ga lahko z zvezno funkcijo ene zvezne neodvisne spremenljivke, ki je v tem primeru čas. Govor se skozi čas spreminja. Enačba:</p>
\[
y = x(t)
\]<ul>
<li>ta signal je <strong>enodimenzionalen</strong>, ker je odvisen od ene spremenljivke (čas \(t\))</li>
<li><strong>zvezni signal</strong> je definiran <strong>v vsakem časovnem trenutku</strong></li>
<li>vrednost signala se skozi čas <strong>neprekinjeno</strong> spreminja</li>
</ul>
<p>Da bi zvezni signal lahko obdelovali z računalnikom, izvedemo postopek <strong>diskretizacije</strong> (<strong>vzorčenja</strong>). Pri tem si želimo, da bi v enakomerno razmaknjenih časovnih trenutkih odtipati vrednosti zveznega signala. S tem dobimo zaporedje številskih vrednosti, kar imenujemo <strong>diskreten signal</strong>. Ko imamo diskreten signal (številke v časovnih trenutkih) odtipamo signal na nek določen časovni interval npr. signal odtipamo na 5, 10, 15 milisekund.</p>
<p>Kakšna pa je vmes vrednost signala med dvema odčitkoma(npr. med 5 in 10 milisekund)?</p>
<p>Tam signal ni definiran, ker ga na teh mestih nismo odtipali. To je ključna razlika med zveznim in diskretnim signalom. Za diskreten signal pravimo, da je vrednost funkcije definirana samo v določenih časovnih trenutkih npr. 5, 10, 15 mislisekund, za vrednosti vmes pa rečemo, da signal ni definiran-<strong>TO JE OPIS DISKRETNEGA SINGALA</strong>.</p>

  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p>Diskreten signal je signal, pri katerem je vrednost funkcije definirana samo v določenih, ločenih časovnih trenutkih (npr. pri 5 ms, 10 ms, 15 ms),
medtem ko za vmesne časovne trenutke signal ni definiran, ker ga nismo odtipali (vzorčili).</p></p>
  </blockquote>

<hr>
<h5 id="2d-slika">
<a class="header-anchor" href="#2d-slika"></a>
2D-slika
</h5><p>Zaenkrat smo si kot vrsto signala ogledali govor. kaj pa slika?</p>
<p>Pri sliki imamo dve osi, višino in dolžino oz. \(x\) in \(y\) os. Zvezno sliko lahko modeliramo kot zvezno funkcijo dveh neodvisnih spremenljivk (dve prostorski osi \(x\) in \(y\)). Enačba za sliko je:</p>
\[
I = I(x, y)
\]<ul>
<li>\(x\) in \(y\) sta prostorski koordinati</li>
<li>\(x, y \in \mathbb{R}\)</li>
<li>slikovna funkcija je definirana v vsaki točki ravnine</li>
</ul>
<p>Zvezna slika (prostorska funkcija) je definirana v vsaki točki ravnine. Katerokoli točko si izberemo, bo funkcija definirana. Za vsak \(x\) in \(y\) vemo vrednost funkcije.</p>
<p>Kaj pa zdaj ta vrednost pomeni?</p>
<p>Pri govoru npr. Večja je vrednost, močnejši je glas. Pri sliki pa je odvisno od naprave. Če bo naprava ultrazvok, bo vrednost predstavljala odboj, pri fotoaparatu bo vrednost predstavljala določen spekter barv, svetlost itd.</p>
<p><strong>Vrednost slikovne funkcije lahko pomeni:</strong></p>
<ul>
<li>svetlost (sivino),</li>
<li>barvo,</li>
<li>temperaturo,</li>
<li>porazdelitev tlaka,</li>
<li>oddaljenost od opazovalca,</li>
<li>…</li>
</ul>

  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p>Zvezna slika je zvezna funkcija dveh neodvisnih spremenljivk (\(x\) in \(y\)), ki je definirana v vsaki točki ravnine.</p></p>
  </blockquote>

<p>Kako pa pridemo iz zvezne slike v diskretno sliko?</p>
<p>To dosežemo podobno kot pri zvoku s postopkom diskretizacije oz. vzorčenja. To pomeni, da ne bomo imeli vse podatke za vsak časovni trenutek.</p>
<p>V smeri \(x\) bomo se zdaj sprehajali s korakom <strong>\(\Delta x\)</strong>.
Podobno pa bomo diskritizirali tudi drugo prostorsko os \(y\) s korakom <strong>\(\Delta y\)</strong>.</p>
<p>Sedaj smo dobili <strong>prostorske trenutke</strong> (to je na presečiščih korakov <strong>\(\Delta x\)</strong> in <strong>\(\Delta y\)</strong>). Diskretna slika je definirana samo v teh diskretnih prostorskih trenutkih. V teh točkah imamo definirane podatke o vrednosti slikovne funkcije.</p>

  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p>Digitalna oz. diskretna 2D-slika je diskretizirana zvezna 2D-slika. Vrednost slikovne funkcije obstaja samo v diskretnih prostorskih trenutnik oz. lokacijah: </p>
\[
I = I(i, j), \quad i, j \in \mathbb{N}
\]</p>
  </blockquote>

<p>Točka nima ploščine in nimamo naprave, ki bi znala zajeti nekaj iz prostora kar nima ploščine. Tega ne znamo naredit. V nekem malem območju zato ocenimo nek mali prostor za predstavitev izbrane točke.</p>
<p>Diskretna slika se najbolj pogosto definira oz. predstavi s pomočjo <strong>matrike</strong>. Pomembno je tudi omenit, da diskretne slike nimajo nikoli neskončno dimenzij-v realnem svetu ko pogledamo vidimo zmeraj neko omejeno območje. V primeru slik, če jih ne bi diskretizirali, bi imeli opravka z neskončnim številom podatkov oz. neskončnimi slikami, kar v praksi ni izvedljivo.</p>
<p>Vrednosti, ki smo jih prebrali v prostorskih trenutkih vpisujemo v matriko.
Osnovni najmanjši gradnik diskretne slike se imenuje <strong>piksel</strong> (picture element oz. slikovni element). Eni programi imenujejo to tudi slikovna točka, kar pa je zavajajoče, saj točke v prostoru ne moremo zajemat, ker točka nima ploščine. Imamo opravka z dimenzijo diskretne slike, podobno kot imamo dimenzije pri matrikah.
Število vrstic in število stolpcev je matrika dimenzije \(M \times N\).</p>
<p>Štetje oz. indeksiranje je vedno problem (ali začeti z 1 ali z 0)-mi bomo indeksirali z 0. Vsako celico matrike (piksel) bomo označili z indeksom vrstice in stolpca \(p = (x, y)\) oz. \(p = (i, j)\).</p>
<p>Vrednosti iz grafa, kjer se po korakih sprehajamo, prenesemo v celice matrike
Npr. 1 korak v smeri\(x\) in 2 koraka v smer\(y\).</p>
<p>Vrednost diskretne slikovne funkcije v pikslu p označimo kot:
</p>
\[
I(p) \text{ oz. } I(i, j)
\]<p>Ker je naša slika omejena ima \(M\) vrstic in \(N\) stolpcev, za vrednosti, ki so zunaj teh dimenzij pa <strong>NE VEMO</strong>.</p>

  <blockquote class="alert-blockquote info">
    <p class="alert-heading">
      Info
    </p>
    <p><p>Tu pri tem predmetu lahko dosti krat rečemo kot odgovor <strong>NE VEMO</strong>, pa še prav bo!</p></p>
  </blockquote>

<p>Najmanjši gradnik slike je piksel in slika ima vse skupaj \(M \times N\) pikslov. Je pa še alternativa za predstavitev slike v obliki satovja namesto matrike. Ene stvari se dajo s satovjem boljše rešit.</p>
<p>Vrednosti v matriki:
Rabimo neko podatkovno strukturo v katero bomo shranili matriko in določili kakšnega tipa so ti podatki. Za določanje tega imamo neka pravila oz. določila:</p>
<p>Najbolj pogosto, če delamo s sivinskimi slikami, piksel hrani vrednost sivine oz. svetlosti (brightness). Vrednost piksla (tj. sivina oziroma svetlost v tem pikslu) leži na intervalu \([0, Q]\). Kot tip se tu najbolj pogosto uporablja za hranjenje vrednosti vsakega piksla 8 bitov. Kot tip podatkov za matriko uporabimo tako 8 bitov. Zato imamo 8 bitne slike. Imamo slike po vrednostih od 0-255. Pri 8-bitnih slikah je
</p>
\[
Q = 2^8 - 1 = 255
\]<ul>
<li>
<p><strong>Sivinske slike</strong> vizualiziramo tako, da vrednost piksla pomeni en vstop v barvno paleto.<br>
V primeru sivinskih slik je to paleta sivin:</p>
</li>
<li>
<p>vrednost <strong>0</strong> → črna barva</p>
</li>
<li>
<p>vrednost <strong>127</strong> → 50 % siva barva</p>
</li>
<li>
<p>vrednost <strong>255</strong> → bela barva</p>
</li>
</ul>
<p>Ko delamo z barvnimi slikami pa uporabimo barvno paleto. Ko imamo barvo imamo 3 barve oz. 3 števila RGB. Piksel mora hranit 3 vrednost in rabimo 3x8 bitov:</p>
<ul>
<li>za rdečo barvo (red) 8 bitov,</li>
<li>za zeleno (green) 8 bitov</li>
<li>za modro (blue) 8 bitov.</li>
</ul>
<p>Če imamo sivinsko sliko, zakaj 8 bitov?
Normalen človek (če nismo supermani) razlikuje nekje 250 različnih barv, zato 8 bitov zadošča-od tukaj sledi 255 različnih nivojev, ker jih več enostavno človeško oko ne loči.</p>
<p>Nekatere medicinske naprave so zmožne piksle odčitat, da vrednost shranimo v 16 bitov in imamo 16 bitne slike. Ljudje jih ne ločimo, nekateri stroji pa jih znajo zajeti. Tako imamo lahko imamo 16 bitne sivinske slike.</p>
<p>Pri delu z slikami in biti je tudi dobro omenit, da bite običajno probamo zbit ali pa zakodirat z manjšo količino-uporabljamo kompresijo, ker so slike prostorsko lahko zelo potratne.</p>
<hr>
<h5 id="video">
<a class="header-anchor" href="#video"></a>
Video
</h5><p>Videoposnetek pa je slika, ki se s časom spreminja.</p>
<p>Videoposnetek bi definirali s tremi neodvisnih spremenljivkami-\(x\) in \(y\) os, ter čas \(t\) skozi katerega se ti 2 komponenti spreminjata.</p>
<p>Diskretni video je zaporedje diskretnih slik.</p>
<hr>
<h4 id="kontrastna-in-prostorska-ločljivost-slike">
<a class="header-anchor" href="#kontrastna-in-prostorska-lo%c4%8dljivost-slike"></a>
Kontrastna in prostorska ločljivost slike
</h4><p>Nalednja dva pojma sta <strong>prostorska</strong> in <strong>kontrastna ločljivost</strong>.</p>
<hr>
<h5 id="kontrastna-ločljivost">
<a class="header-anchor" href="#kontrastna-lo%c4%8dljivost"></a>
Kontrastna ločljivost
</h5>
  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p><strong>Kontrastna ločljivost</strong> je tesno povezana s številom bitov, ki jih uporabljamo za predstavitev vrednosti piksla. Predstavlja število različnih sivinskih nivojev, ki jih lahko vsebuje slika.</p></p>
  </blockquote>

<h6 id="teoretična-kontrastna-ločljivost">
<a class="header-anchor" href="#teoreti%c4%8dna-kontrastna-lo%c4%8dljivost"></a>
Teoretična kontrastna ločljivost
</h6><p><strong>Teoretična maksimalna kontrastna ločljivost</strong> je določena s številom možnih vrednosti piksla in je enaka:</p>
\[
Q + 1
\]<p>kjer je \(Q\) največja možna vrednost piksla.</p>
<p>Pri 8-bitni sivinski sliki velja:
</p>
\[
Q = 2^8 - 1 = 255
\]<p>kar pomeni, da ima slika 256 različnih sivinskih nivojev.</p>
<h6 id="dejanska-kontrastna-ločljivost">
<a class="header-anchor" href="#dejanska-kontrastna-lo%c4%8dljivost"></a>
Dejanska kontrastna ločljivost
</h6><p><strong>Dejanska kontrastna ločljivost</strong> pomeni število sivinskih nivojev, ki so dejansko prisotni v sliki. Določimo jo tako, da v sliki preštejemo različne sivinske vrednosti.</p>
<ul>
<li>višja kontrastna ločljivost → več sivinskih nivojev</li>
<li>nižja kontrastna ločljivost → manj sivinskih nivojev</li>
</ul>
<p>Višja kontrastna ločljivost omogoča ohranitev več podrobnosti v sceni.<br>
Z več sivinskimi nivoji lahko natančneje predstavimo prehode med svetlimi in temnimi območji slike.</p>
<p>Manjša kontrastna ločljivost pomeni, da se bližnji sivinski nivoji zlijejo med seboj, kar povzroči izgubo informacij –<br>
podrobnosti se združijo z večjimi, enotnimi območji slike.</p>
<h6 id="vpliv-kontrastne-ločljivosti-na-analizo-slike">
<a class="header-anchor" href="#vpliv-kontrastne-lo%c4%8dljivosti-na-analizo-slike"></a>
Vpliv kontrastne ločljivosti na analizo slike
</h6><p>Če želimo biti pri analizi slike natančni, kontrastne ločljivosti ne smemo zmanjševati, saj bi s tem izgubili pomembne podrobnosti.</p>
<p>Kadar pa nas zanimajo predvsem večje oblike oziroma večji objekti na sliki, je zmanjšanje kontrastne ločljivosti smiselno.<br>
Pri realno-časovnih aplikacijah, kjer je čas obdelave omejen, lahko z zmanjšanjem kontrastne ločljivosti:</p>
<ul>
<li>zmanjšamo količino podatkov,</li>
<li>pospešimo obdelavo,</li>
<li>prihranimo prostor za shranjevanje in prenos.</li>
</ul>
<h6 id="kdaj-uporabiti-zmanjšano-kontrastno-ločljivost">
<a class="header-anchor" href="#kdaj-uporabiti-zmanj%c5%a1ano-kontrastno-lo%c4%8dljivost"></a>
Kdaj uporabiti zmanjšano kontrastno ločljivost
</h6><ul>
<li>ko nas zanimajo predvsem velike oblike in objekti na sliki</li>
<li>ko želimo prihraniti čas obdelave in prostor za shranjevanje</li>
</ul>
<h6 id="kdaj-zmanjšane-kontrastne-ločljivosti-ne-uporabiti">
<a class="header-anchor" href="#kdaj-zmanj%c5%a1ane-kontrastne-lo%c4%8dljivosti-ne-uporabiti"></a>
Kdaj zmanjšane kontrastne ločljivosti ne uporabiti
</h6><ul>
<li>ko je potrebna visoka natančnost</li>
<li>ko so pomembne podrobnosti in detajli na sliki</li>
</ul>
<hr>
<h5 id="prostorska-ločljivost">
<a class="header-anchor" href="#prostorska-lo%c4%8dljivost"></a>
Prostorska ločljivost
</h5>
  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p><strong>Prostorska ločljivost</strong> je določena kot število pikslov na določeno mersko enoto. Omogoča povezavo med svetom pikslov (meritve v slikah) in realnim svetom, kjer uporabljamo merske enote, kot so mm, cm ali m.</p></p>
  </blockquote>

<p>Izražena je kot:</p>
<ul>
<li>število pikslov na mersko enoto (npr. piksel/mm)</li>
</ul>
<p>Prostorsko ločljivost lahko definiramo posebej:</p>
<ul>
<li>v smeri osi \(x\),</li>
<li>v smeri osi \(y\).</li>
</ul>
<p>V večini aplikacij predpostavimo, da so piksli <strong>kvadratni</strong>, zato sta ločljivosti v obeh smereh enaki.</p>

  <blockquote class="alert-blockquote warning">
    <p class="alert-heading">
      Warning
    </p>
    <p><p><strong>Prostorske ločljivosti ne smemo zamenjevati z velikostjo slike. Čeprav sta prostorska ločljivost in velikost slike pogosto povezani med sabo, to NISTA ISTA POJMA!</strong></p></p>
  </blockquote>

<blockquote>
<p><strong>Primer: A4 list</strong></p>
<p>Dimenzije A4 lista:<br>
– \(y = 297\,\text{mm}\)<br>
– \(x = 210\,\text{mm}\)</p>
<p>Če A4 list skeniramo ali fotografiramo pri prostorski ločljivosti <strong>100 pikslov na mm</strong>, dobimo sliko velikosti:<br>
– \(29700 \times 21000\) pikslov</p>
<p>Če isti list zajamemo pri prostorski ločljivosti <strong>1 piksel na mm</strong>, dobimo sliko velikosti:<br>
– \(297 \times 210\) pikslov</p>
<p>V obeh primerih gre za isti fizični objekt, vendar z različno prostorsko ločljivostjo in posledično različno velikostjo slike.<br>
<strong>Iz primera vidimo, da večja prostorska ločljivost ne pomeni večjega objekta, temveč le natančnejši opis istega objekta.</strong></p>
</blockquote>
<h6 id="prostorska-ločljivost-z-vidika-obdelave-slik">
<a class="header-anchor" href="#prostorska-lo%c4%8dljivost-z-vidika-obdelave-slik"></a>
Prostorska ločljivost z vidika obdelave slik
</h6><p>Višja prostorska ločljivost pomeni:</p>
<ul>
<li>več podrobnosti,</li>
<li>več informacij,</li>
<li>večjo porabo procesorskega časa,</li>
<li>večjo velikost slike.</li>
</ul>
<p>Če je na sliki objekt, bo pri prostorski ločljivosti <strong>100 pikslov na mm</strong> en milimeter objekta opisan s 100 piksli. Pri prostorski ločljivosti <strong>1 piksel na mm</strong> bo isti milimeter opisan le z enim pikslom.</p>
<p>Če podrobnosti niso pomembne in nas zanimajo le <strong>grobe oblike</strong>, si lahko privoščimo zmanjšanje prostorske ločljivosti. To bo pomenilo, da se bo del informacij iz slike posledično izgubil (detajli se zlijejo z večjimi področji). Manjša prostorska ločljivost pa bo posledično pomenila tudi manjšo velikost slike.</p>
<h6 id="pomen-prostorske-ločljivosti-v-praksi">
<a class="header-anchor" href="#pomen-prostorske-lo%c4%8dljivosti-v-praksi"></a>
Pomen prostorske ločljivosti v praksi
</h6><p>Brez podane prostorske ločljivosti (npr. pri medicinskem slikanju) bi zdravniku lahko povedali le, da je tumor velik <strong>35 pikslov</strong>, kar nima pravega pomena. Ko pa poznamo prostorsko ločljivost, lahko isto informacijo izrazimo v realnih merah, na primer: približno 2 mm. To omogoča smiselno interpretacijo slike v realnem svetu.</p>
<hr>
<p>Pikslu \(p = [i, j]\) lahko v sliki \(I\) definiramo njegove sosede (tj. sosednje piksle) na dva načina:</p>
<ul>
<li><strong>v 4-sosedstvu</strong></li>
<li><strong>v 8-sosedstvu</strong></li>
</ul>
<p><strong>4 sosedstvo</strong> pomeni da bomo imeli 4 sosede. To so tisti piksli s kateri ima naš piksel skupno stranico.
Če bi stvar posplošili v 3D-nimamo piksel, ampak imamo voksel(x,y,z). Ima toliko sosedov kolikor ima skupnih ploskev (6 sosedov).</p>
<p><strong>8 sosedstvo</strong> pa pomeni, da ima piksel 8 sosedov. 4 piksli so tisti s katerimi si deli stranico, ostale 4 piksli pa so še tisti s katerimi se dotika v kotih. V 3d bi pa imeli prav tako tiste s katerimi se stika na vogalih-skupaj 26 pikslov. (3x3x3-1)-pri tem računamo še -1, da odštejemo ta piksel, ki ga opazujemo oz. od katerega sosede gledamo.</p>
<p>Sosedstvo je pomembno v funkcijah, kjer moramo določiti, v kakšnem okolju naj algoritmi upoštevajo sosede piksle ali voksle.</p>
<hr>
<h3 id="uporabljene-oznake">
<a class="header-anchor" href="#uporabljene-oznake"></a>
Uporabljene oznake
</h3><ul>
<li><strong>Konsistentnost uporabljenih oznak</strong> skozi zapiske.</li>
<li><strong>Vektorji</strong> – majhne ali velike črke, zapisane krepko (odvisno od opazovanega prostora).<br>
<em>Primer:</em> vektor <strong>b</strong> = [b₀, b₁, &hellip;, bₙ₋₁], vektor <strong>A</strong></li>
<li><strong>Matrike</strong> – velike črke, zapisane v <em>sans-serif</em> pisavi.<br>
<em>Primer:</em> matrika <strong>A</strong></li>
<li><strong>Slika</strong> – I</li>
<li><strong>Zaporedje 2D-slik</strong> – I</li>
<li><strong>Velikost slike (št. vrstic in stolpcev)</strong> – M × N</li>
<li><strong>Piksel</strong> – p = [i, j]</li>
<li><strong>Točke, premice in ravnine v prostoru</strong> – črke zapisane <em>kurzivno</em>.<br>
<em>Primer:</em> ravnina Π</li>
<li><strong>Funkcije</strong> – velike črke, zapisane v <em>kaligrafski pisavi</em>.<br>
<em>Primer:</em> funkcija F()</li>
<li><strong>Standardni odklon</strong> – σ</li>
<li><strong>Povprečje</strong> – \(\bar{p}\)</li>
<li><strong>Absolutna vrednost</strong> – |p|</li>
<li><strong>Delta (Δ)</strong> – znak delta, označba za spremembo ali razliko vrednosti (npr. Δx = sprememba v x)</li>
</ul>
<hr>
<h3 id="operacije-nad-slikami">
<a class="header-anchor" href="#operacije-nad-slikami"></a>
Operacije nad slikami
</h3><p><strong>Operacije nad slikami</strong> so podobne matričnemu računu in jih opravljamo na nivoju istoležnih pikslov.</p>
<ul>
<li>
<p><strong>Seštevanje/odštevanje slik:</strong><br>
</p>
\[
  C = A \pm B \quad \Rightarrow \quad C(i,j) = A(i,j) \pm B(i,j)
  \]<blockquote>
<p>Seštevanje/odštevanje slik-vzamemo istoležne piksle iz slike A in istoležne piksle iz slike B in jih seštejemo.</p>
</blockquote>
</li>
<li>
<p><strong>Množenje/deljenje slik:</strong><br>
</p>
\[
  C = A \cdot / B \quad \Rightarrow \quad C(i,j) = A(i,j) \cdot / B(i,j)
  \]<blockquote>
<p>Množenje/deljenje slik-vzamemo ij-ti piksel iz prve slike in ij-ti piksel iz druge slike in shranimo rezultat na ij-ti piksel v rezultatu.</p>
</blockquote>
</li>
<li>
<p><strong>Množenje s skalarjem:</strong><br>
</p>
\[
  C = \alpha A \quad \Rightarrow \quad C(i,j) = \alpha A(i,j)
  \]</li>
<li>
<p><strong>Kvadriranje slik:</strong><br>
</p>
\[
  C = A^2 \quad \Rightarrow \quad C(i,j) = (A(i,j))^2
  \]</li>
</ul>
<h2 id="model-kamere-in-zajemanje-slik">
<a class="header-anchor" href="#model-kamere-in-zajemanje-slik"></a>
Model kamere in zajemanje slik
</h2><h3 id="zajemanje-slik-s-kamerami-ccd">
<a class="header-anchor" href="#zajemanje-slik-s-kamerami-ccd"></a>
Zajemanje slik s kamerami CCD
</h3><h4 id="proces-formiranja-slike">
<a class="header-anchor" href="#proces-formiranja-slike"></a>
Proces formiranja slike
</h4><p>Kako pridemo do slike?</p>
<p>Imamo <strong>fotoaparat</strong> – leče, zaslonko, zadaj imamo film ali danes senzor. Ko pritisnemo gumb za slikanje, se zaslonka odpre, svetloba pride na senzor in slika se shrani na pomnilni medij.</p>
<p>Danes digitalni fotoaparati temeljijo na <strong>senzorju</strong>, občutljivem na svetlost. Temu seznoru pravimo <strong>CCD senzor</strong>. Poleg njega pa je še <strong>CMOS senzor</strong>, ki se pogosto uporablja pri fotoaparatih na telefonih. Ta senzor je cenejši, vendar deluje podobno kot CCD.</p>
<hr>
<h5 id="senzor-ccd">
<a class="header-anchor" href="#senzor-ccd"></a>
Senzor CCD
</h5><p>Senzor CCD je običajno pravokotne oblike in razdeljen na posamezne elemente, ki so zloženi v matriki po vrsticah in stolpcih. Vsak elementek CCD je občutljiv na svetlost in iz njega nastane <strong>en piksel</strong>. Elementke CCD si lahko predstavljamo kot kvadratne &ldquo;koše&rdquo;, ki zbirajo svetlobo. Vsako polje lahko meri količino svetlobne energije, ki pade nanjo, pri čemer se količina svetlobna energije, ki pade na dano polje meri skozi neko določeno časovno obdobje.</p>
<hr>
<h5 id="svetloba-in-fotoni">
<a class="header-anchor" href="#svetloba-in-fotoni"></a>
Svetloba in fotoni
</h5><p>Svetloba sestoji iz <strong>fotonov</strong>, ki jih lahko predstavljamo kot žogice. Ko pritisnemo sprožilec, svetloba pride skozi lečo in zaslonko do senzorja. V kvadratne &ldquo;koše&rdquo; se ujame več fotonov tam, kjer je svetloba močnejša, in manj fotonov tam, kjer je temneje. <strong>Večja svetlost bo pomenila večji naboj v elementku CCD.</strong></p>
<p>To je bil sedaj opisan prvi korak, kjer smo akumulirali svetlobni naboj. Sedaj sledi pretvorba tega ujetega svetlobnega naboja v sliko.</p>
<hr>
<h5 id="pretvorba-svetlobnega-naboja-v-sliko">
<a class="header-anchor" href="#pretvorba-svetlobnega-naboja-v-sliko"></a>
Pretvorba svetlobnega naboja v sliko
</h5><p>Akumulirani svetlobni naboj pretvorimo v <strong>zvezni signal</strong> (napetost v odvisnosti od časa). Pretvorba poteka <strong>vrstico po vrstici</strong>, podobno kot igra &ldquo;4 v vrsto&rdquo;: spodnja vrstica se obdeluje prva. Začnemo s spodnjo linijo našega senzorja (matrike) in naboj pretvorimo v zvezni signal (napetost v odvisnosti od časa). Višji kot je svetlobni naboj notri, višja bo napetost in večja bo amplituda (podobno je obratno-nižji bo naboj notri, manjša bo napetost). Vrstico za vsak element pretvorimo v vrednost svetlobnega signala. Na koncu pride kontrolni signal in se vrstica shrani (posreduje v serijski izhodni register). Nato gre naslednja vrstica po podobnem postopku notri za obdelavo.</p>
<p>Za tem korakom sledi diskretizacija signala.</p>
<hr>
<h5 id="diskretizacija-in-ad-pretvorba">
<a class="header-anchor" href="#diskretizacija-in-ad-pretvorba"></a>
Diskretizacija in AD pretvorba
</h5><p>Register posreduje prejet naboj polja (enega na enkrat) v izhodni <strong>ojačevalnik</strong>, ki zgenerira ustrezen analogni oz. zvezni signal, pri čemerdobimo v signalu večje razlike. Ta signal gre nato v <strong>AD pretvornik</strong>, da pretvorimo analogni signal v digitalni signal (diskretizacija). V fotoaparatih je čas vzorčenja oz. trenutki ko bo signal diskretniziran (\(\Delta T\)) tovarniško zapečeno. Ta vrednost določa koliko vzorcev moremo dobit, da lahko dobimo vsako vrstico.</p>
<p>Če napetost preseže maksimalno vrednost \(U_\text{MAX}\), AD pretvornik odreže višek. AD pretvornik shrani vrednosti v <strong>register</strong>, običajno 8-bitni, ki lahko hrani <strong>256 različnih nivojev</strong> (od 0 do 255). Vsak ta nivo dobi neko številko oz. indeks. Po AD pretvorbi dobimo <strong>matriko</strong>, ki je enake velikosti in ima enako število elementov kot senzor CCD.</p>
<p>Postopek ponavljamo za vse vrstice senzorja. Za eno vrstico dobimo signal, to damo v AD pretvornik. V posameznem trenutku ne vrnemo napetost, ampak številko nivoja v katerega je svetlobna točka padla. Ko pridemo do kontrolnega signala vzamemo naslednjo vrstico in spet pretvorimo.</p>
<p>Branje oz. formiranje slike, po tem postopku, se lahko ponovi večkrat na sekundo (npr. 30 fps), lahko pa traja tudi več ur (npr. v astronomiji).</p>
<p>Za korakom diskretizacije sledi shranjevanje slike.</p>
<hr>
<h5 id="shranjevanje-slike">
<a class="header-anchor" href="#shranjevanje-slike"></a>
Shranjevanje slike
</h5><p>Matriko na koncu shranimo v <strong>pomnilnik</strong> – to je slika v surovem formatu. Pri videu se ta postopek zgodi večkrat na sekundo.</p>
<hr>
<p>Zgoraj opisan postopek velja za sivinsko sliko. Pri barvni sliki pa so potrebni za vsako barvo 3 komponente RGB. Kako priti torej do barvnih slik?</p>
<p>Obstajata 2 pristopa:</p>
<ul>
<li><strong>single-shot</strong> (zaslonka se 1x odpre)</li>
<li><strong>multi-shot</strong> (zaslonka se večkrat odpre)</li>
</ul>
<p>Dodatno pa glede na ceno obstaja še ločitev na <strong>cenejši</strong> in <strong>dražji način</strong>.</p>
<hr>
<h5 id="single-shot">
<a class="header-anchor" href="#single-shot"></a>
Single-shot
</h5><p>Eden cenejših pristopov za zajem barvne slike je <strong>single-shot</strong> metoda. Svetloba je sestavljena iz različnih valovnih dolžin, pri čemer nas pri barvnem zajemu zanimajo tri osnovne komponente: <strong>rdeča (R), zelena (G) in modra (B)</strong>.</p>
<p>Če senzor ni opremljen z nobenim filtrom, se fotoni sicer ujamejo, vendar dobimo le sivinsko sliko brez barvnih informacij. Zato se pri single-shot pristopu uporablja <strong>barvni filter</strong>, najpogosteje <strong>Bayerjev filter</strong>. Z njim se izvede postopek Bayerjevega demoziciranja s čimer dobimo digitalno barvno sliko.</p>
<p>Bayerjev filter je razporejen v matriki:</p>
<ul>
<li>v eni vrstici se izmenjujeta rdeča in zelena barva,</li>
<li>v naslednji vrstici pa zelena in modra barva.
Gre za interpoliranje podatkov na osnovi vrednosti sosednjih pikslov.</li>
</ul>
<p>Filter mora biti dovolj velik, da prekrije celoten senzor. Če je posamezen CCD element prekrit z rdečim filtrom, bo zaznal le rdeče fotone, medtem ko se zeleni in modri izgubijo. Enako velja za zelene in modre filtre – vsak element zazna le eno barvno komponento.</p>
<h6 id="single-shot--cenejša-rešitev">
<a class="header-anchor" href="#single-shot--cenej%c5%a1a-re%c5%a1itev"></a>
Single-shot – cenejša rešitev
</h6><p>Pri tej rešitvi imamo še vedno <strong>en sam CCD senzor</strong>, pretvorba signala pa poteka podobno kot pri sivinski sliki. Razlika je v tem, da vsak piksel izmeri <strong>le eno barvno komponento</strong>, za popoln RGB zapis pa potrebujemo še preostali dve.</p>
<p>Manjkajoči barvni komponenti se določita <strong>hevristično z interpolacijo</strong> iz sosednjih pikslov. Na primer:<br>
če je pri nekem pikslu izmerjena zelena vrednost, se rdeča in modra komponenta izračunata s pomočjo interpolacijskih funkcij in vrednosti bližnjih pikslov.</p>
<p>Na ta način dobimo tri matrike:</p>
<ul>
<li>matriko rdeče barve (R),</li>
<li>matriko zelene barve (G),</li>
<li>matriko modre barve (B).</li>
</ul>
<p>To predstavlja osnovni <strong>single-shot pristop</strong>, ki je cenovno ugoden, vendar manj natančen.</p>
<h6 id="single-shot--dražja-rešitev">
<a class="header-anchor" href="#single-shot--dra%c5%beja-re%c5%a1itev"></a>
Single-shot – dražja rešitev
</h6><p>Dražja rešitev predpostavlja uporabo <strong>treh senzorjev</strong>, pri čemer je vsak namenjen določenemu barvnemu spektru (R, G ali B). Najdražji del sistema sta senzor in leča.</p>
<p>Ena izmed izvedb je, da so senzorji zloženi kot nekakšen <strong>sendvič</strong> in izdelani iz posebnih materialov, ki prepuščajo le določeno valovno dolžino svetlobe. Tako vsak senzor neposredno zajame svojo barvno komponento brez potrebe po interpolaciji.</p>
<p>Druga rešitev pa je da imamo 3 senzorje, ki so prostorsko razmaknjeni po fotoaparatu, ki ima na vhodu stekleno prizmo. Sem noter pride svetloba, ki se na tej prizmi nato lomi. Imamo 3 senzorje in svetloba se lomi na enega od treh senzorjev. Fotoni se zgrabijo na pravilen senzor s pomočjo steklene prizme, ki razprši to svetlobo. Za vsaki senzor treba ponoviti to zgodbo enako kot prej-to je natančneje, ampak je zato tudi dražje.</p>
<hr>
<h5 id="multi-shot">
<a class="header-anchor" href="#multi-shot"></a>
Multi-shot
</h5><h6 id="multi-shot-pristop">
<a class="header-anchor" href="#multi-shot-pristop"></a>
Multi-shot pristop
</h6><p>Multi-shot metoda ne pomeni, da uporabnik večkrat ročno pritisne sprožilec, temveč da se <strong>zaslonka samodejno odpre večkrat</strong>, običajno trikrat – enkrat za vsako barvno komponento. Senzor se tukaj zaporedoma 3x v zelo kratkem časovnem intervalu izpostavi svetlobi (sceni). Pri tem se ob odpiranju zaslonke pred senzor položi filter, ki prepušča le določeno barvno komponento.</p>
<p>Pri tem uporabljamo različne vrste filtrov. Ti so lahko mehanski ali akustični. Pri mehanskih filtrih je pred senzorjem nameščen filter, ki prepušča določeno barvo:</p>
<ol>
<li>najprej rdečo – zajame se rdeča komponenta,</li>
<li>nato se filter zamenja in zajame modra komponenta,</li>
<li>na koncu še zelena komponenta.</li>
</ol>
<p>Vsaka barva se zajame ločeno, nastali signali pa se združijo v končno barvno sliko.</p>
<p>Ta pristop ni primeren za hitro spreminjajoče se scene, saj lahko pride do <strong>zamegljenosti</strong>, zato se uporablja predvsem pri statičnih prizorih.</p>
<hr>
<h5 id="velikost-senzorjev">
<a class="header-anchor" href="#velikost-senzorjev"></a>
Velikost senzorjev
</h5><p>Senzorji so lahko zelo majhni, poznamo pa tudi <strong>full-frame senzorje</strong>, ki so bistveno večji. Velikost senzorja in posameznih elementov močno vpliva na kakovost slike.</p>
<p>Če na zelo majhen senzor pade velika količina fotonov, se kakovost slike poslabša. Zato velja, da so <strong>večji senzorji in večji piksli praviloma boljši</strong>, saj omogočajo boljši zajem svetlobe.</p>
<hr>
<h3 id="modeli-kamer">
<a class="header-anchor" href="#modeli-kamer"></a>
Modeli kamer
</h3><p>V računalniškem vidu je pri določenih aplikacijah nujno razumeti <strong>matematično formiranje slike</strong> – torej kako se slika opiše z matematičnimi modeli.</p>
<p>Obravnavali bomo:</p>
<ul>
<li>matematične modele kamere,</li>
<li>načine, kako proces zajema slike opisati z matematičnimi formulami.</li>
</ul>
<p>Modela, kot sta <strong>kamera obskura</strong> in <strong>kamera s tankimi lečami</strong>, sta pogosto preveč poenostavljena, medtem ko je <strong>kamera z lečami</strong> najbolj realističen model.</p>
<hr>
<h4 id="kamera-na-luknjico-camera-obscura">
<a class="header-anchor" href="#kamera-na-luknjico-camera-obscura"></a>
Kamera na luknjico (camera obscura)
</h4><p><strong>Kamera na luknjico</strong> je eden najstarejših modelov kamere, poznan že v času Aristotla. Gre za zelo preprosto napravo, ki jo sestavljata majhna odprtina (luknjica) in slikovna ravnina. Scena pred kamero se skozi odprtino preslika na notranjo, hrbtno stran kamere, kjer nastane obrnjena slika. Delovanje kamere na luknjico temelji na <strong>perspektivni projekciji</strong>.</p>
<p>Luknjico lahko matematično obravnavamo kot <strong>eno samo točko v prostoru</strong>. Iz vsake točke opazovane scene potuje svetlobni žarek, ki gre skozi luknjico in se projicira na slikovno ravnino. Točka na sliki nastane tam, kjer ta premica seka slikovno ravnino. Na ta način se vsaka točka v prostoru preslika v ustrezno točko na sliki.</p>
<p>Zaradi perspektivne projekcije se velikost objektov na sliki spreminja glede na njihovo oddaljenost od kamere. Če imamo dva enako velika predmeta, ki se nahajata na različnih razdaljah od kamere, bo:</p>
<ul>
<li>bolj oddaljen predmet na sliki videti manjši,</li>
<li>bližji predmet pa večji,</li>
</ul>
<p>čeprav sta v resničnem svetu enake velikosti. Ta opisan <strong>perspektivni efekt</strong> je ena ključnih lastnosti perspektivne projekcije.</p>
<p>Stari fotoaparati so za zajem slike uporabljali <strong>fotografski film</strong>. Po zajemu je bilo film potrebno razviti v temnici, kjer so ga s posebnimi kemičnimi tekočinami obdelali, da se je slika trajno zapisala.</p>
<h5 id="koordinatni-sistem-kamere-na-luknjico">
<a class="header-anchor" href="#koordinatni-sistem-kamere-na-luknjico"></a>
Koordinatni sistem kamere na luknjico
</h5><p>Kameri na luknjico priredimo koordinatni sistem:</p>
<ul>
<li>
<p>$O$ – izhodišče je v luknjici</p>
</li>
<li>
<p>$\Pi'$ – slikovna ravnina</p>
</li>
<li>
<p>$\mathbf{i}$ in $\mathbf{j}$ – bazna vektorja ravnine, ki je paralelna ravnini $\Pi'$</p>
</li>
<li>
<p>$f'$ – oddaljenost ravnine $\Pi'$ od luknjice v smeri vektorja $\mathbf{k}$ (merjeno pozitivno)</p>
</li>
<li>
<p>$C'$ – slikovni center (središče)</p>
<ul>
<li>leži na presečišču optične osi in ravnine $\Pi'$</li>
</ul>
</li>
<li>
<p>Optična os:</p>
<ul>
<li>je pravokotna na ravnino $\Pi'$</li>
<li>poteka skozi luknjico</li>
</ul>
</li>
<li>
<p>Točko $C'$ lahko uporabimo kot izhodišče slikovne ravnine</p>
<ul>
<li>pomembno za kalibracijo kamere</li>
</ul>
</li>
</ul>
<h5 id="kako-določimo-za-točko-v-sceni-njen-položaj-na-sliki">
<a class="header-anchor" href="#kako-dolo%c4%8dimo-za-to%c4%8dko-v-sceni-njen-polo%c5%beaj-na-sliki"></a>
Kako določimo za točko v sceni njen položaj na sliki?
</h5><p>Glede na definiran koordinatni sistem imamo torej projekcijsko oz. slikovno ravnino, ki jo definiraza bazna vektorja $\mathbf{i}$ in $\mathbf{j}$. Imamo pa še točko $P$, ki se preko perspektivne projekcije preslika v točko $P'$.</p>
<ul>
<li>Točka $P$ – točka iz scene</li>
</ul>
$$
P = [x, y, z]
$$<ul>
<li>Točka $P'$ – slika točke $P$ na slikovni ravnini</li>
</ul>
$$
P' = [x', y', z']
$$<ul>
<li>Točka $P'$ leži na slikovni ravnini, zato velja:</li>
</ul>
$$
z' = f'
$$<ul>
<li>Koordinati $x'$ in $y'$ določimo iz opazovanja geometrije (perspektivna projekcija):</li>
</ul>
$$
x' = \frac{f' x}{z}
$$$$
y' = \frac{f' y}{z}
$$<p>Zanima nas določitev koordinat točke $P'$.<br>
Poznamo koordinate točke $P$:</p>
$$
P(x, y, z)
$$<p>Te koordinate so podane v nekih merskih enotah, npr.:</p>
$$
P(100, 200, 450)
$$<p>kjer vrednosti lahko predstavljajo centimetre (lahko pa tudi dm, m itd.).</p>
<p>Točka $P$ se preko <strong>perspektivne projekcije</strong> preslika v točko $P'$.</p>
<p>Točka $P'$ ima koordinate:</p>
$$
P'(x', y', z')
$$<p>Ker točka $P'$ leži na slikovni ravnini, velja:</p>
$$
z' = f'
$$<p>Vprašanje pa je, kako določimo $x'$ in $y'$.<br>
To določa matematični model perspektivne projekcije:</p>
$$
x' = f' \left(\frac{x}{z}\right)
$$$$
y' = f' \left(\frac{y}{z}\right)
$$<p>Ti dve formuli povesta, kako se točka preslika na slikovno ravnino.</p>
<p>Pomembno:<br>
$x'$, $y'$ in $z'$ so še vedno izraženi v isti merski enoti kot $x$, $y$, $z$. <strong>Tukaj še ne govorimo o pikslih.</strong><br>
Če so $x, y, z$ podani v cm, so tudi $x', y', z'$ v cm.</p>
<blockquote>
<p>Primer</p>
<p>Podano imamo točko $P$ s koordinatami ($x, y, z$), ter podatek za oddaljenost ravnine od luknjice ($f'$):</p>
$$ P(100, 200, 450), \quad f' = 150 $$<p>Zanima nas določitev koordinat točke $P'$. Ker točka $P'$ leži na slikovni ravnini, velja $z' = f'$. V tem primeru to pomeni, da je $z' = 150$. Določiti moramo torej $x'$ in $y'$.</p>
<p>Izračun:</p>
$$ x' = f' \cdot \left(\frac{x}{z}\right) = 150 \cdot \left(\frac{100}{450}\right) = 33{,}3 $$$$ y' = f' \cdot \left(\frac{y}{z}\right) = 150 \cdot \left(\frac{200}{450}\right) = 66{,}6 $$</blockquote>
<h5 id="omejitve-modela-kamere-na-luknjico">
<a class="header-anchor" href="#omejitve-modela-kamere-na-luknjico"></a>
Omejitve modela kamere na luknjico
</h5><p>Model kamere na luknjico je nekoliko <strong>preoptimističen</strong>, saj predpostavlja, da je luknjica idealna točka. V resnici pa ta luknjica ni matematična točka, ampak ima določeno ploščino, predstavlja odprtino (npr. krožno), skozi katero v praksi ne prehaja le en žarek ampak več žarkov. Ker skozi odprtino prehaja več žarkov, se preslikana točka na slikovni ravnini nekoliko <strong>razmaže</strong> (ni popolnoma ostra). Manjša kot je odprtina, manjša je razmazanost.</p>
<p>Zato v model kamere uvedemo <strong>leče</strong> (običajno pred odprtino). S tem imamo luknjico, pred njo pa zbiralne (konveksne) leče.</p>
<p>Leče omogočijo:</p>
<ul>
<li>boljšo fokusacijo žarkov,</li>
<li>ostrejšo sliko,</li>
<li>bolj realističen model kamere.</li>
</ul>
<hr>
<h4 id="model-s-tankimi-lečami">
<a class="header-anchor" href="#model-s-tankimi-le%c4%8dami"></a>
Model s tankimi lečami
</h4><p>Lastnost zbiralne leče katera sestavlja ta model je, da <strong>fokusira oziroma zbira žarke</strong>. Žarki, ki izhajajo iz iste točke, se zaradi leče ne razpršijo, temveč se na koncu zberejo v eni točki na slikovni ravnini. Lastnosti leče določata dve goriščni točki. Ti dve točki sta na razdalji $f$, kjer je $f$ <strong>goriščna razdalja</strong> leče.</p>
<h5 id="koordinatni-sistem-modela-s-tankimi-lečami">
<a class="header-anchor" href="#koordinatni-sistem-modela-s-tankimi-le%c4%8dami"></a>
Koordinatni sistem modela s tankimi lečami
</h5><p>Koordinatno izhodišče sedaj postavimo v <strong>središče leče</strong>.</p>
<p>Ponovno imamo točko:</p>
$$
P(x, y, z)
$$<p>Podobno kot pri sistemu modela kamere na luknjico, nas tudi sedaj zanima kam na slikovni ravnini se preslika dana točka $P$. Ker imamo odprtino, skozi lečo potuje več žarkov iz iste točke.</p>
<p>Pri tem na zbiralni leči obravnavamo tri značilne (mejne) primere (žarke):</p>
<ul>
<li>
<p>Žarek, ki je <strong>vzporeden optični osi</strong>, se po prehodu skozi lečo lomi skozi drugo gorišče in se nato seka s slikovno ravnino.</p>
</li>
<li>
<p>Žarek, ki gre ravno skozi <strong>središče leče</strong>, se ne lomi in potuje naravnost do slikovne ravnine.</p>
</li>
<li>
<p>Žarek, ki gre skozi <strong>prvo goriščno točko</strong>, se po prehodu skozi lečo lomi tako, da postane vzporeden optični osi, nato pa se seka s slikovno ravnino.</p>
</li>
</ul>

  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p>Če je objekt (npr. točka $P$) na ustrezni razdalji, se vsi trije žarki zberejo v isti točki na slikovni ravnini. <strong>VENDAR TO NE VELJA VEDNO!</strong>. Velja samo takrat, ko je objekt (npr. točka $P$ v našem primeru) na primerni razdalji od slikovne ravnine, da se bodo dani žarki zbrali v isti točki. V takem primeru je scena v <strong>ostrem fokusu</strong> in velja relacija oziroma enačba:</p>
$$\frac{1}{z'} - \frac{1}{z} = \frac{1}{f}$$<p>kjer:</p>
<ul>
<li>$z$ predstavlja razdaljo objekta,</li>
<li>$z'$ predstavlja razdaljo slike,</li>
<li>$f$ predstavlja goriščno razdaljo.</li>
</ul>
<p>Če ta pogoj ni izpolnjen, se žarki ne zberejo v eni točki in slika ni ostra.</p></p>
  </blockquote>

<p><strong>FOV (Field of View)</strong> predstavlja del scene, ki se projicira na senzor oziroma kamero.</p>
<p>FOV je odvisen od:</p>
<ul>
<li>lastnosti leče,</li>
<li>velikosti senzorja.</li>
</ul>
<p>To je tisti del prostora, ki ga kamera &ldquo;vidi&rdquo;.</p>
<h5 id="omejitve-modela">
<a class="header-anchor" href="#omejitve-modela"></a>
Omejitve modela
</h5><p>Idealnih tankih leč s popolnimi lastnostmi v praksi ne moremo izdelati. Zato je tudi model &ldquo;kamera na luknjico z lečo&rdquo;, še vedno nekoliko <strong>preoptimističen matematični model</strong> realne kamere.</p>
<hr>
<h4 id="model-z-debelimi-lečami">
<a class="header-anchor" href="#model-z-debelimi-le%c4%8dami"></a>
Model z debelimi lečami
</h4><p>Najbolj realističen model je <strong>model kamere z debelimi lečami</strong>. To je najboljši približek dejanskemu fizikalnemu dogajanju v kameri.</p>
<p>Debela leča je poleg:</p>
<ul>
<li>dveh goriščnic,</li>
<li>goriščne razdalje $f$,</li>
</ul>
<p>opisana še z:</p>
<ul>
<li><strong>glavnima točkama leče</strong>,</li>
<li><strong>razdaljo med njima</strong>.</li>
</ul>
<p>S temi parametri lahko natančneje opišemo obnašanje debele leče.</p>
<h5 id="koordinatni-sistem-modela-z-debelimi-lečami">
<a class="header-anchor" href="#koordinatni-sistem-modela-z-debelimi-le%c4%8dami"></a>
Koordinatni sistem modela z debelimi lečami
</h5><p>Ponovno nas zanima:</p>
<ul>
<li>kako se točka projicira na slikovno ravnino,</li>
<li>kako se žarki lomijo oziroma zbirajo.</li>
</ul>
<p>Tudi debela leča ima lastnost zbiranja žarkov, vendar je model nekoliko bolj kompleksen kot pri tanki leči.</p>
<p>Pri modelu debele leče obravnavamo tri značilne primere:</p>
<ul>
<li>
<p>Žarek, ki je <strong>vzporeden optični osi</strong>, se lomi tako, da pri drugi glavni točki spremeni smer in se pod določenim kotom preslika na slikovno ravnino.</p>
</li>
<li>
<p>Žarek, ki gre skozi <strong>prvo gorišče</strong>, se po lomljenju usmeri tako, da postane vzporeden optični osi.</p>
</li>
<li>
<p>Žarek, ki zadene <strong>prvo glavno točko</strong>, se preslika skozi drugo glavno točko in nato seka slikovno ravnino.</p>
</li>
</ul>
<hr>
<h5 id="omejitve-modela-1">
<a class="header-anchor" href="#omejitve-modela-1"></a>
Omejitve modela
</h5><p>Tudi ta model je še vedno <strong>preoptimističen</strong>, saj popolne leče v praksi ne moremo izdelati.</p>
<p>V realnih sistemih se pojavljajo:</p>
<ul>
<li>geometrijska popačenja,</li>
<li>optične aberacije,</li>
<li>druge nepravilnosti.</li>
</ul>
<hr>
<h3 id="parametri-kamere">
<a class="header-anchor" href="#parametri-kamere"></a>
Parametri kamere
</h3><p>Ne glede na to, kateri model uporabimo (luknjica, tanka leča, debela leča), ostajamo pri istem osnovnem principu:</p>
<p>Imamo točko v prostoru:</p>
$$
P(x, y, z)
$$<p>Ta točka se preslika na slikovno ravnino v koordinatah, ki so še vedno izražene v <strong>merskih enotah</strong> (npr. cm, mm). V praksi pa kamera na koncu ne vrne koordinat v centimetrih, temveč <strong>pikslih</strong>.</p>

  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p><strong>Notranji parametri kamere</strong> omogočijo preslikavo iz sveta merskih enot v svet pikslov. Tako dobimo končno digitalno sliko, kjer je vsaka točka predstavljena kot piksel.</p></p>
  </blockquote>

<p>Če želimo uporabiti matematične enačbe projekcije, pa moramo poznati <strong>koordinatni sistem naše kamere</strong>. Za dosego tega, pa je potrebno točke, ki smo jih dobili iz koordinatnega sistema v naravi pretvorit v koordinatni sistem, kot bi ga zajela naša kamera. Določitev tega nam omogočajo <strong>zunanji parametri kamere</strong>.</p>

  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p><strong>Zunanji parametri kamere</strong> so potrebni za merjenje razdalj, ter opis lege in orientacije v prostoru. Zunanji parametri kamere so potrebni, ker ne znamo neposredno meriti lokacije točke glede na koordinatni sistem kamere in moramo svetovni koordinatni sistem pretvoriti v koordinatni sistem kamere.</p></p>
  </blockquote>

<h4 id="notranji-parametri-kamere">
<a class="header-anchor" href="#notranji-parametri-kamere"></a>
Notranji parametri kamere
</h4><p>Imamo koordinatni sistem kamere in znamo izmeriti lokacijo točke glede nanj. V kamero vstavimo <strong>CCD senzor</strong>. Tudi za senzor lahko vpeljemo koordinatni sistem.</p>
<ul>
<li>Izberemo koordinatno izhodišče.</li>
<li>Glede na izhodišče štejemo piksle.</li>
</ul>
<p>Na ta način preslikamo točke iz koordinatnega sistema kamere v koordinatni sistem v pikslovnem sistemu.</p>
<p>Na senzorju se nahaja <strong>središče slikovne ravnine</strong>, vendar pikslov ne merimo glede na sredino senzorja.</p>
<p>Piksle začnemo šteti od:</p>
<ul>
<li>vrstice: 0, 1, 2, 3, &hellip;</li>
<li>stolpca: 0, 1, 2, 3, &hellip;</li>
</ul>
<p>in <strong>ne uporabljamo negativnih števil</strong>. Zaradi tega koordinatno izhodišče slikovnega sistema ni v središču senzorja, temveč v enem od njegovih vogalov.</p>
<h5 id="glavna-točka--parametra--in">
<a class="header-anchor" href="#glavna-to%c4%8dka--parametra--in"></a>
Glavna točka – parametra \( u_0 \) in \( v_0 \)
</h5><p>Prva dva notranja parametra sta:</p>
<ul>
<li>\( u_0 \) – premik v smeri vrstic</li>
<li>\( v_0 \) – premik v smeri stolpcev</li>
</ul>
<p>Ta dva parametra določata, kje se nahaja <strong>koordinatno izhodišče</strong> glede na pikslovni koordinatni sistem.</p>
<h5 id="parametra--in">
<a class="header-anchor" href="#parametra--in"></a>
Parametra \( \alpha \) in \( \beta \)
</h5><p>Naslednja dva notranja parametra sta:</p>
<ul>
<li>\( \alpha \)</li>
<li>\( \beta \)</li>
</ul>
<p>V teh dveh parametrih je skrita <strong>velikost piksla</strong>.</p>

  <blockquote class="alert-blockquote warning">
    <p class="alert-heading">
      Warning
    </p>
    <p><p>\( \alpha \) in \( \beta \) nista neposredno velikosti piksla, temveč predstavljata produkt goriščne razdalje in prostorske ločljivosti. Pri tem je \( \alpha \) prostorska ločljivost v smeri \( x \), \( \beta \) pa prostorska ločljivost v smeri \( y \).</p></p>
  </blockquote>

<p>Velja:</p>
<ul>
<li>\( \alpha = f \cdot s_x \)</li>
<li>\( \beta = f \cdot s_y \)</li>
</ul>
<p>kjer:</p>
<ul>
<li>\( f \) – goriščna razdalja,</li>
<li>\( s_x \) – prostorska ločljivost v smeri \( x \),</li>
<li>\( s_y \) – prostorska ločljivost v smeri \( y \).</li>
</ul>
<p>Ključni namen teh parametrov je:</p>
<blockquote>
<p>prehod iz merskih enot (cm, mm) v svet pikslov.</p>
</blockquote>
<h5 id="kot-theta">
<a class="header-anchor" href="#kot-theta"></a>
Kot theta \( \theta \)
</h5><p>Mi uvedemo koordinatni sistem, ki je enak velikosti našega senzorja. Kot med baznimi vektorji je \( 90^\circ \) stopinj, ampak v praksi takšnega senzorja ne znamo naredit, da bi imel točno \( 90^\circ \). Zato rečemo, da je kot med osema (osema po vrsticah in stolpcih) kot \( \theta \). To je kot med osjo vrstic in osjo stolpcev.</p>
<p>Parameter \( \theta \) opisuje napako pri izdelavi senzorja (odstopanje od pravokotnosti).</p>
<h5 id="pet-notranjih-parametrov-kamere">
<a class="header-anchor" href="#pet-notranjih-parametrov-kamere"></a>
Pet notranjih parametrov kamere
</h5><p>Skupaj imamo torej 5 notranjih parametrov:</p>
<ol>
<li>\( u_0 \) – premik kamere v smeri vrstic</li>
<li>\( v_0 \) – premik kamere v smeri stolpcev</li>
<li>\( \alpha \) – skaliranje v smeri \( x \)</li>
<li>\( \beta \) – skaliranje v smeri \( y \)</li>
<li>\( \theta \) – kot med osema</li>
</ol>
<p>Pomen:</p>
<ul>
<li>2 parametra za premik koordinatnega sistema,</li>
<li>2 parametra za pretvorbo iz cm (oz. merskih enot) v piksle,</li>
<li>1 parameter za napako pri izdelavi senzorja.</li>
</ul>
<h5 id="kalibracijska-matrika">
<a class="header-anchor" href="#kalibracijska-matrika"></a>
Kalibracijska matrika \( K \)
</h5><p>Iz teh parametrov lahko sestavimo <strong>kalibracijsko matriko</strong> velikosti \( 3 \times 3 \):</p>
\[
K =
\begin{bmatrix}
\alpha & -\alpha \cot \theta & u_0 \\
0 & \dfrac{\beta}{\sin \theta} & v_0 \\
0 & 0 & 1
\end{bmatrix}
\]<p>Ta matrika omogoča prehod iz koordinat kamere v pikslovni sistem. S pomočjo te matrike naredimo projekcijsko matriko $M$ velikosti \( 3 \times 4 \) oz. perspektivno projekcijsko matriko.</p>
<h5 id="projekcijska-matrika">
<a class="header-anchor" href="#projekcijska-matrika"></a>
Projekcijska matrika
</h5><p>S pomočjo notranjih in zunanjih parametrov dobimo <strong>projekcijsko matriko</strong>:</p>
\[
M = K [R , t]
\]<p>Imenujemo jo tudi <strong>perspektivna projekcijska matrika</strong> in je velikosti \(3 \times 4\).</p>
<h5 id="model-kamere--matrična-enačba">
<a class="header-anchor" href="#model-kamere--matri%c4%8dna-ena%c4%8dba"></a>
Model kamere – matrična enačba
</h5><p>Model kamere je zapisan kot:</p>
\[
p = \frac{1}{z} M P
\]<h5 id="homogene-koordinate">
<a class="header-anchor" href="#homogene-koordinate"></a>
Homogene koordinate
</h5><p>Točka v prostoru:</p>
\[
P = (x, y, z)
\]<p>v homogenih koordinatah zapišemo kot:</p>
\[
P = (x, y, z, 1)
\]<p>Dodamo pa ji še četrto komponento oziroma dimanzijo z vrednostjo 1, da lahko izvajamo matrični račun.</p>
<h5 id="projekcija">
<a class="header-anchor" href="#projekcija"></a>
Projekcija
</h5><ul>
<li>\( P \) – točka v prostoru (v homogenih koordinatah)</li>
<li>\( p \) – projicirana točka na sliki</li>
</ul>
<p>Mala črka \( p \) predstavlja slikovno točko po projekciji.</p>
<p>To predstavlja celoten matematični model kamere:
3D točka → projekcija → 2D piksel.</p>
<hr>
<h4 id="zunanji-parametri-kamere">
<a class="header-anchor" href="#zunanji-parametri-kamere"></a>
Zunanji parametri kamere
</h4><p>Poleg notranjih parametrov pa potrebujemo tudi <strong>zunanje parametre kamere</strong>.</p>
<p>Imamo koordinatni sistem kamere, vendar v realnosti ne moremo meriti prostora neposredno glede na središče leče.</p>
<p>Običajno imamo:</p>
<ul>
<li>referenčni realni (world) koordinatni sistem,</li>
<li>merilni sistem (npr. laser), s katerim izmerimo koordinate točk v prostoru.</li>
</ul>
<p>Točke, ki jih izmerimo z laserjem, so podane v <strong>world koordinatnem sistemu</strong>. Za model kamere pa potrebujemo točke v <strong>koordinatnem sistemu kamere</strong>. Zato moramo pretvoriti točke iz realnega (world) koordinatnega sistema v koordinatni sistem kamere. S tem dobimo točke, ki bi jih imeli, če bi laser šel iz kamere.</p>
<h5 id="povezava-koordinatnih-sistemov">
<a class="header-anchor" href="#povezava-koordinatnih-sistemov"></a>
Povezava koordinatnih sistemov
</h5><p>Imamo torej dva koordinatna sistema:</p>
<ul>
<li>svetovni (world) koordinatni sistem</li>
<li>koordinatni sistem kamere</li>
</ul>
<p>Da ju pa povežemo in da lahko izvedemo pretvorbo iz enega koordinatnega sistema v drugega, moramo izvesti:</p>
<ol>
<li><strong>Translacijo</strong> (poravnava izhodišč)</li>
<li><strong>Rotacijo</strong> (poravnava osi)</li>
</ol>
<h6 id="translacija">
<a class="header-anchor" href="#translacija"></a>
Translacija
</h6><p>Translacija je podana s tremi parametri:</p>
<ul>
<li>premik po osi \( x \)</li>
<li>premik po osi \( y \)</li>
<li>premik po osi \( z \)</li>
</ul>
<p>To zapišemo kot translacijski vektor:</p>
\[
t =
\begin{bmatrix}
t_x \\
t_y \\
t_z
\end{bmatrix}
\]<h6 id="rotacija">
<a class="header-anchor" href="#rotacija"></a>
Rotacija
</h6><p>Rotacijo definiramo s tremi koti:</p>
<ul>
<li>rotacija okoli osi \( x \)</li>
<li>rotacija okoli osi \( y \)</li>
<li>rotacija okoli osi \( z \)</li>
</ul>
<p>Te kote običajno označimo kot:</p>
\[
\alpha, \beta, \gamma
\]<p>Rotacijo izvedemo kot kompozitum rotacij:</p>
<ol>
<li>najprej okoli osi \( x \),</li>
<li>nato okoli osi \( y \),</li>
<li>nato okoli osi \( z \).</li>
</ol>
<p>Rotacijsko matriko zapišemo kot kompozitum rotacij:</p>
\[
R = R_x R_y R_z
\]<p>kjer so</p>
\[
R_x =
\begin{bmatrix}
1 & 0 & 0 \\
0 & \cos \alpha & \sin \alpha \\
0 & -\sin \alpha & \cos \alpha
\end{bmatrix}
\]\[
R_y =
\begin{bmatrix}
\cos \beta & 0 & -\sin \beta \\
0 & 1 & 0 \\
\sin \beta & 0 & \cos \beta
\end{bmatrix}
\]\[
R_z =
\begin{bmatrix}
\cos \gamma & \sin \gamma & 0 \\
-\sin \gamma & \cos \gamma & 0 \\
0 & 0 & 1
\end{bmatrix}
\]<p>* Koti so merjeni v protiurni smeri.</p>
<p>Zunanji parametri so torej:</p>
<ul>
<li>3 parametri translacije</li>
<li>3 parametri rotacije</li>
</ul>
<p>Skupaj 6 \text{ zunanjih parametrov}</p>
<p>S temi parametri podamo transformacijo med obema koordinatnima sistemoma.</p>
<p>S zunanjimi in notranjimi parametri imamo sedaj imamo popoln model kamere. Imamo 5 notranjih in 6 zunanjih parametrov kamere. Te parametre pa moremo nekje dobit-temu pravimo <strong>kalibracija kamere</strong>.</p>
<hr>
<h3 id="geometrijsko-kalibriranje-kamer">
<a class="header-anchor" href="#geometrijsko-kalibriranje-kamer"></a>
Geometrijsko kalibriranje kamer
</h3><h4 id="parametri-kamere-in-kalibracija">
<a class="header-anchor" href="#parametri-kamere-in-kalibracija"></a>
Parametri kamere in kalibracija
</h4><p>Notranji parametri kamere modelirajo lastnosti kamere. Omogočajo pretvorbo merskega sveta (realnih enot) v svet pikslov, tako da na koncu dobimo sliko v pikslih. Za to so zadolženi <strong>notranji parametri kamere</strong>. Skupaj imamo <strong>5 notranjih parametrov kamere</strong>.</p>
<p>Drugi nabor parametrov so <strong>zunanji parametri kamere</strong>. Vse točke v sceni bi morali meriti glede na koordinatni sistem kamere, kar je v praksi nemogoče. Zato potrebujemo referenčni (world) koordinatni sistem, katerega v koordinatni sistem kamere pretvorijo zunanji parametri kamere. Skupaj imamo <strong>6 zunanjih parametrov kamere</strong>.</p>
<p>Ali nam lahko kdo poda vseh 11 parametrov kamere?</p>
<p><strong>Notranji parametri</strong>
Nemogoče je izdelati dve popolnoma enaki kameri. Tudi če je leča izdelana strojno, bo druga leča vedno nekoliko drugačna.</p>
<p><strong>Zunanji parametri</strong>
Te je še težje podati. Položaj točk v prostoru merimo glede na nek referenčni koordinatni sistem, kar prav tako ni popolnoma natančno oziroma neposredno podano.</p>
<p>Zato je nemogoče, da bi nam nekdo enostavno &ldquo;serviral&rdquo; vse parametre kamere. Potrebujemo <strong>kalibriranje kamere</strong>. Geometrijsko kalibriranje pomeni, da se naučimo (ocenimo) parametre kamere.</p>
<p>Potrebujemo <strong>korespondenčne pare</strong>:</p>
<ul>
<li>poznano neko točko v prostoru, npr.<br>
\[
  P_1 = (x_1, y_1, z_1)
  \]
katere koordinate poznamo,</li>
<li>ter piksel na sliki, v katerega se ta točka preslika.</li>
</ul>
<p>Takšne pare zapišemo kot:</p>
\[
\{ (P_i, p_i) \}
\]<p>kjer:</p>
<ul>
<li>\(P_i\) predstavlja točko v prostoru,</li>
<li>\(p_i\) pa njen pripadajoči piksel na sliki.</li>
</ul>
<p>Potrebujemo torej točke v prostoru, za katere vemo, v kateri piksel se preslikajo.</p>
<p>S pomočjo <strong>kalibracijskega objekta</strong> dosežemo, da moramo neposredno izmeriti samo 1 ali 2 točki, nato pa lahko iz njih določimo še vse ostale točke.</p>
<p>Kalibracijo lahko izvedemo tudi ročno, tako da sami izberemo določene točke. Vendar je tak pristop časovno potraten.</p>
<p>Vse kalibracijske metode so <strong>optimizacijske metode</strong>.</p>
<p>Imamo matematični model kamere:</p>
\[
p = \frac{1}{z} M P
\]<p>kjer:</p>
<ul>
<li>\( p \) predstavlja <strong>piksel</strong>,</li>
<li>\( P \) predstavlja točko v prostoru (v homogenih koordinatah),</li>
<li>\( M \) je projekcijska matrika.</li>
</ul>
<p>Neznanka v tej enačbi je <strong>projekcijska matrika \( M \)</strong>.</p>
<h4 id="linearni-postopek-kalibriranja">
<a class="header-anchor" href="#linearni-postopek-kalibriranja"></a>
Linearni postopek kalibriranja
</h4><p>Problem linearne metode je, da deluje pravilno le, če imamo <strong>perfektno izmerjene korespondenčne pare</strong>.</p>
<p>V praksi pa vedno pride do napak pri določanju teh točk:</p>
<ul>
<li>napaka pri določanju pikslov,</li>
<li>napaka pri merjenju točk v realnem svetu.</li>
</ul>
<p>Bolj kot so podatki nenatančni, slabši je rezultat kalibracije.</p>
<h5 id="postopek">
<a class="header-anchor" href="#postopek"></a>
Postopek
</h5><p>Začnemo s projekcijsko enačbo.</p>
<p>Za vsak korespondenčni par \((P_i, p_i)\):</p>
<ul>
<li>dobimo <strong>2 enačbi</strong>,</li>
<li>ki ju zapišemo kot <strong>2 vrstici</strong> v matriki sistema.</li>
</ul>
<p>Če imamo \( n \) korespondenčnih parov, ima matrika sistema \(2n \text{ vrstic}\), ker iz vsakega para dobimo dve enačbi.</p>
<p>Na primer:</p>
<ul>
<li>
<ol>
<li>in 2. vrstica → prvi korespondenčni par</li>
</ol>
</li>
<li>
<ol start="3">
<li>in 4. vrstica → drugi korespondenčni par</li>
</ol>
</li>
<li>itd.</li>
</ul>
<p>Za kalibracijo kamere potrebujemo <strong>12 enačb</strong> (ker ima projekcijska matrika \( M \) 12 elementov). Za vsak korespondenčni par pa dobimo 2 enačbi in 2 vrstici v matriki P.</p>
<p>Ker iz vsakega korespondenčnega para dobimo 2 enačbi:</p>
\[
\frac{12}{2} = 6
\]<p>Potrebujemo <strong>minimalno 6 korespondenčnih parov</strong>.</p>
<ul>
<li>Če imamo <strong>točno 6 parov</strong>, dobimo eksaktno rešitev.</li>
<li>Če imamo <strong>več kot 6 parov</strong>, dobimo sistem s presežkom enačb.</li>
</ul>
<p>V primeru, da imamo več kot 6 parov se pojavijo srednje minimizacije oz. napake, vendar je rezultat te kalibracije boljši. Več korespondenčnih parov kot uporabimo, bolj robusten in natančen je rezultat.</p>

  <blockquote class="alert-blockquote warning">
    <p class="alert-heading">
      Warning
    </p>
    <p><p>Pri izbiri točk za kalibracijo:</p>
<p><strong>TOČKE NE SMEJO LEŽATI V ISTI RAVNINI!</strong></p>
<p>Če bi vse točke ležale v isti ravnini:</p>
<ul>
<li>bi kalibracija še vedno dala rešitev,</li>
<li>vendar bi pri reprojekciji (preslikavi iz pikslov nazaj v realni svet) dobili napake.</li>
</ul>
<p>Zato morajo biti točke razporejene v prostoru in ne smejo vse ležati na isti ravnini.</p></p>
  </blockquote>

<h4 id="geometrijsko-kalibriranje-kamere">
<a class="header-anchor" href="#geometrijsko-kalibriranje-kamere"></a>
Geometrijsko kalibriranje kamere
</h4><p>Sistem lahko zapišemo kot:</p>
$$
P \times \mathbf{m} = \mathbf{0}
$$<p>Dimenzije:</p>
<ul>
<li>$P \in \mathbb{R}^{2n \times 12}$</li>
<li>$\mathbf{m} \in \mathbb{R}^{12 \times 1}$</li>
<li>$\mathbf{0} \in \mathbb{R}^{2n \times 1}$</li>
</ul>
<p>(Trivialna rešitev je, da bi $\mathbf{m}$ bil iz samih ničel, to nas ne zanima.)</p>
<p>Ta metoda (geometrijsko kalibriranje kamere), je precej občutljiva – podatki morajo biti zelo točni. Parametri kamere so v projekcijski matriki $M$.</p>
<p>Iz piksla lahko pridemo nazaj v prostor, kar pa brez modela</p>
$$
\mathbf{p} = \frac{1}{z} M \mathbf{P}
$$<p>ne moremo.</p>
<p>Cilj je narediti sistem računalniškega vida – od zajema do končne odločitve.</p>
<h2 id="predobdelava-slik">
<a class="header-anchor" href="#predobdelava-slik"></a>
Predobdelava slik
</h2><p>Pri predobdelavi slik sta ključna dva cilja:</p>
<ol>
<li>Želimo popraviti napake, ki so se zgodile pri zajemu slike.</li>
<li>V slikah želimo poudariti informacijo, ki nas zanima.</li>
</ol>
<p>Če imamo vpliv nad okoljem, kjer zajemamo sliko (npr. svetila), potem lahko, če vidimo, da slika ni ustrezna, poskusimo ponovno zajeti sliko, pri tem pa popravimo dejavnike v okolju (npr. osvetlitev, svetila).</p>
<p>Če pa delamo s satelitskimi slikami ali medicinskimi napravami, pa je problem, da se ne moremo vrniti nazaj in slike ponovno zajeti<br>
Podobno velja tudi za slike v naravi, kjer je veliko odvisno od vremena.</p>
<p>Če se lahko vrnemo, poskusimo sliko popraviti že pri zajemu. Če to ni mogoče, pa moramo problem rešiti programsko.</p>
<p>Če sami načrtujemo (dizajniramo) sistem, lahko veliko stvari izboljšamo že v fazi zasnove. Lažje pa nam je tudi, če poznamo podatke o degradaciji slike (napakah ob zajemu).</p>
<p>Pri obdelavi slik velja:</p>
<ul>
<li>Če uporabimo pravo metodo za določeno degradacijo, bo rezultat uspešen.</li>
<li>Če uporabimo metodo, ki ni primerna za dano degradacijo, lahko sliko še poslabšamo.</li>
</ul>
<p>Podobno kot pri zdravilih:</p>
<ul>
<li>Če vzamemo zdravilo za bolezen, ki je nimamo, nam ne bo koristilo in lahko celo škoduje.</li>
<li>Enako velja pri obdelavi slik – napačna metoda lahko sliko poslabša.</li>
</ul>
<p>Slika obstaja v nekem prostoru, obdelava slike pa jo transformira v nov prostor.</p>
<p>Te transformacije:</p>
<ul>
<li>povzročijo izgubo določenih informacij,</li>
<li>niso bijektivne.</li>
</ul>
<p>Obdelava slik je običajno sestavljena iz več zaporednih transformacij.</p>
<blockquote>
<p><strong>Operacije pri obdelavi slik</strong></p>
<p><strong>1. Točkovne (pixel-to-pixel) operacije</strong></p>
<p>Pixel-to-pixel operacije delujejo tako, da vzamemo en pixel, ga podamo v neko funkcijo (operacijo) in dobimo nov (spremenjen) pixel. Vsak izhodni pixel je odvisen samo od ustreznega vhodnega pixla.</p>
<p><strong>2. Lokal­ne operacije (z okolico)</strong></p>
<p>Pri tej varianti vzamemo pixel, upoštevamo tudi njegove sosednje pixle (okolico), vse skupaj podamo v funkcijo in dobimo ven nov pixel. Izhodna vrednost je torej odvisna od lokalne okolice.</p>
<p><strong>3. Algoritemske metode</strong></p>
<p>Gre za kompleksnejše postopke, kjer obdelava temelji na določenem algoritmu, ki lahko vključuje več korakov, pravil ali odločitev.</p>
<p><strong>4. Globoko učenje</strong></p>
<p>Sem spadajo globoko učenje (deep learning), nevronske mreže in druge metode umetne inteligence.</p>
</blockquote>
<h3 id="spreminajnje-kontrasta">
<a class="header-anchor" href="#spreminajnje-kontrasta"></a>
Spreminajnje kontrasta
</h3><p>Točkovna operacija deluje tako, da imamo neko sliko in nad vsakim pixlom izvedemo isto transformacijo.</p>
<h4 id="linearizacija-sivin">
<a class="header-anchor" href="#linearizacija-sivin"></a>
Linearizacija sivin
</h4><p>Prvi tak postopek je <strong>linearizacija sivin</strong>.</p>
<p>Imamo formulo:</p>
$$
g' = \frac{Q}{\max - \min} \left( g - \min \right)
$$<p>Linearizacija se pogosto uporablja za vizualizacijo. Lahko pa se uporablja tudi kot vmesni korak pri nadaljnji obdelavi slike.</p>
<h4 id="histogram-sivin">
<a class="header-anchor" href="#histogram-sivin"></a>
Histogram sivin
</h4><p>Histogram sivin je vektor (polje), ki ima toliko elementov, kolikor znaša kontrastna ločljivost slike. Posamezen element histograma sivin beleži število pixlov, ki imajo določeno sivinsko vrednost.</p>
<p>Primer:
8-bitna sivinska slika ima 256 sivinskih nivojev. Zato ima histogram 256 elementov in kontrastno ločljivost 256.</p>
<p>Če seštejemo vse elemente histograma, dobimo skupno število vseh pixlov v sliki.</p>
<p>Histogram sivin običajno vizualiziramo s pomočjo <strong>stolpčnih grafov</strong>.</p>
<p>Histogram sivin <strong>ne vsebuje prostorske informacije</strong>.</p>
<p>To pomeni, da v histogramu samo štejemo pixle. Notri v histogramu tako <strong>ni informacije o tem, kje v sliki se posamezni pixli nahajajo</strong>.</p>
<p>Zato lahko:</p>
<ul>
<li>dve sliki enake velikosti</li>
<li>z enakim histogramom sivin</li>
</ul>
<p>vsebujeta popolnoma različne vsebine.</p>
<p>Pri delu s histogrami sivin poskušamo histogram &ldquo;razpotegniti&rdquo;, da so sivinske vrednosti čim bolj enakomerno porazdeljene in histogram s tem kar se da uravnan. Najbolj ostri vrhovi na histogramu običajno predstavljajo ključne oziroma bistvene elemente slike. Histogram sivin sam po sebi ni metoda za spreminjanje kontrasta, nam pa pomaga pri analizi kontrasta slike.</p>
<h5 id="metoda-izenačitev-histograma">
<a class="header-anchor" href="#metoda-izena%c4%8ditev-histograma"></a>
Metoda: Izenačitev histograma
</h5><p><strong>Izenačitev histograma</strong> pomeni, da želimo doseči, da so vse sivinske vrednosti približno enako zastopane. V praksi tega popolnoma ne moremo doseči, je pa to cilj metode.</p>
<p>Z vidika kontrasta:</p>
<ul>
<li>Najvišje (ostre) vrhove na histogramu raztegnemo,
da postanejo bolj kontrastni.</li>
<li>Kjer so doline (manj zastopane vrednosti),
sklepamo, da informacija ni tako pomembna,
zato tam lahko izgubimo nekaj podatkov.</li>
</ul>

  <blockquote class="alert-blockquote warning">
    <p class="alert-heading">
      Warning
    </p>
    <p><p>Izenačitev histograma ni isto kot linearizacija!</p></p>
  </blockquote>

<h5 id="prenosne-funkcije">
<a class="header-anchor" href="#prenosne-funkcije"></a>
Prenosne funkcije
</h5><p><strong>Prenosne funkcije</strong> lahko vizualiziramo v grafu prenosnih funkcij.
Če gre prenosna funkcija nad identiteto, potem točkovna operacija sliko posvetli. Če pa gre prenosna funkcija pod identiteto, pa točkovna operacija sliko potemni.</p>

  <blockquote class="alert-blockquote warning">
    <p class="alert-heading">
      Warning
    </p>
    <p><p>Linearizacija ne posvetli slike!</p></p>
  </blockquote>

<hr>
<h3 id="lokalne-operacije-oz-filtriranje-slik">
<a class="header-anchor" href="#lokalne-operacije-oz-filtriranje-slik"></a>
Lokalne operacije oz. filtriranje slik
</h3><p>Imamo sliko in izbran pixel.<br>
Pri filtriranju slik opazujemo:</p>
<ul>
<li>izbran pixel</li>
<li>njegovo okolico</li>
</ul>
<p>Vzeli bomo ta pixel in njegove sosednje pixle, jih podali v funkcijo, in dobili nov rezultat. Pri tem poznamo točkovne operacije in filtriranje.</p>
<h4 id="točkovne-operacije">
<a class="header-anchor" href="#to%c4%8dkovne-operacije"></a>
Točkovne operacije
</h4><ul>
<li>Delamo pixel po pixel.</li>
<li>Lahko uporabljamo isto matriko oziroma sliko za vhod in izhod.</li>
<li>Vsak pixel je obdelan neodvisno od drugih.</li>
</ul>
<h4 id="filtriranje">
<a class="header-anchor" href="#filtriranje"></a>
Filtriranje
</h4><ul>
<li>Uporabljamo pixel in njegovo okolico.</li>
<li>Potrebujemo <strong>novo sliko (novo matriko)</strong> za zapis rezultatov.</li>
<li>Ne pišemo nazaj na isto lokacijo (zaradi tega temu pravimo filtriranje, saj imamo vhodno in izhodno filtrirano sliko).</li>
</ul>
<p>Vprašanje pri filtriranju je, kako določiti funkcijo $F$, ki iz vhodnih vrednosti generira novo vrednost pixla.</p>
<p>Filter si lahko predstavljamo kot <strong>črno škatlo</strong>, nekaj damo notri in dobimo nekaj nazaj ven.</p>
<p>Večina filtrov je:</p>
<ol>
<li><strong>Linearnih</strong></li>
<li><strong>Premično neodvisnih</strong></li>
</ol>
<h5 id="1-linearnost">
<a class="header-anchor" href="#1-linearnost"></a>
1. Linearnost
</h5><p>Če imamo dva vhoda $x_1$ in $x_2$:</p>
<ul>
<li>Če v sistem podamo $x_1$, dobimo določen rezultat.</li>
<li>Če podamo $x_2$, dobimo določen <strong>drugačen</strong> rezultat.</li>
</ul>
<p>Če pa podamo linearno kombinacijo obeh vhodov:</p>
$$
a x_1 + b x_2
$$<p>potem dobimo na izhodu linearno kombinacijo $x_1$ in $x_2$:</p>
$$
a F(x_1) + b F(x_2)
$$<p>Ne glede na vrstni red podajanja vhodov, ali prvo damo notri kot vhod $x_1$ in potem $x_2$, ali pa obratno. To je lastnost linearnega sistema.</p>
<h5 id="2-premična-neodvisnost">
<a class="header-anchor" href="#2-premi%c4%8dna-neodvisnost"></a>
2. Premična neodvisnost
</h5><p>Sistem je premično neodvisen, če:</p>
<ul>
<li>posledica ne prehiteva vzroka,</li>
<li>odziv sistema ni odvisen od absolutne lokacije, ampak le od relativnega premika.</li>
</ul>
<blockquote>
<p>Primer:
Ne slišimo zvoka, če prej ne potrkamo po tabli.</p>
</blockquote>
<p>Obnašanje filtra oziroma črne škatle lahko opišemo s pomočjo <strong>enotinega odziva (impulznega odziva)</strong>. Ta popolnoma določa obnašanje linearnega premično neodvisnega sistema.</p>
<h4 id="definicija-filtra">
<a class="header-anchor" href="#definicija-filtra"></a>
Definicija filtra
</h4><h5 id="določitev-filtra">
<a class="header-anchor" href="#dolo%c4%8ditev-filtra"></a>
Določitev filtra
</h5><p>Najprej je potrebno določiti filter. Učinek filtra mora biti tak, kot si ga želimo. Filter je podan z <strong>enotnim (impulznim) odzivom</strong>. Enotni odziv je matrika, ki vsebuje koeficiente (uteži).</p>
<p>Običajno filter označimo s $H$, kjer je $H$ matrika.</p>
<h5 id="matrika-filtra-maska">
<a class="header-anchor" href="#matrika-filtra-maska"></a>
Matrika filtra (maska)
</h5><p>Tej matriki določimo:</p>
<ul>
<li>velikost (dimenzijo),</li>
<li>vrednosti (koeficiente / uteži).</li>
</ul>
<h6 id="dimenzija-filtra">
<a class="header-anchor" href="#dimenzija-filtra"></a>
Dimenzija filtra
</h6><p>Velikost oziroma dimenzija filtra določa kako veliko okolico pixla bomo opazovali. Filter položimo tako, da pokrije izbran pixel, ter njegovo okolico. S tem definiramo lokalno območje obdelave.</p>
<h6 id="vrednosti-uteži-koeficientov">
<a class="header-anchor" href="#vrednosti-ute%c5%bei-koeficientov"></a>
Vrednosti uteži (koeficientov)
</h6><p>Števila (uteži) v matriki določajo kako bo funkcija kombinirala vrednosti pixlov, ter kakšen bo učinek filtriranja.</p>

  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p>Dimenzija maske določa <strong>katero okolico opazujemo</strong>, vrednosti v maski pa določajo <strong>kako jo obdelamo</strong>. To dvoje skupaj določa lastnosti filtra.</p></p>
  </blockquote>

<h5 id="implementacija">
<a class="header-anchor" href="#implementacija"></a>
Implementacija
</h5><p>Implementacijsko je najlažje definirati maske oziroma okolice pikslov kot kvadratno masko (npr. 3×3, 5×5), saj jo lahko preprosto implementiramo s for-zankami.</p>
<p>Če imamo za okolico masko drugačne (ne kvadratne) oblike (npr. krožno ali nepravilno obliko), uporabimo kvadratno matriko, vrednosti, ki jih ne želimo upoštevati, pa nastavimo na 0.</p>
<h4 id="filtriranje-1">
<a class="header-anchor" href="#filtriranje-1"></a>
filtriranje
</h4><p>Ko imamo enkrat definiran filter, lahko začnemo s filtriranjem. Vsaka maska ima <strong>sredino</strong> (sredinski element maske). Masko navidezno postavimo nad sliko tako, da prekrije del slike. Nato izračunamo <strong>skalarni produkt</strong> med <strong>vrednostmi maske</strong> in <strong>vrednostmi pixlov slike</strong>, ki jih maska prekriva.</p>
<p>To pomeni:</p>
<ul>
<li>vsak pixel množimo z ustrezno vrednostjo v maski,</li>
<li>vse zmnožke seštejemo,</li>
<li>dobimo novo vrednost za en pixel izhodne slike.</li>
</ul>
<p>To je izračun za en pixel.</p>
<p>Za implementacijo potrebujemo 4 for-zanke:</p>
<ol>
<li>Zanka čez vse vrstice za vse piksle slike</li>
<li>Zanka čez vse stolpce za vse piksle slike</li>
<li>Zanka čez vrstice za vse piksle maske</li>
<li>Zanka čez stolpce za vse piksle maske</li>
</ol>
<p>Skupaj torej 4 for-zanke. Temu postopku pravimo <strong>konvolucija</strong>.</p>
<p>$I$ je vhodna slika.</p>
<h5 id="problemi-pri-konvoluciji">
<a class="header-anchor" href="#problemi-pri-konvoluciji"></a>
Problemi pri konvoluciji
</h5><h6 id="problem-robnih-pixlov">
<a class="header-anchor" href="#problem-robnih-pixlov"></a>
Problem robnih pixlov
</h6><p>Kaj narediti z robnimi pixli, ko del maske pade izven slike?</p>
<p><strong>Možna rešitev 1: Ničelno dopolnjevanje (zero padding)</strong></p>
<p>Če maska pade izven slike:</p>
<ul>
<li>vrednosti izven slike obravnavamo kot 0</li>
<li>to pomeni, da vrednosti maske izven slike množimo z 0</li>
</ul>
<p>Prednost:</p>
<ul>
<li>dimenzije vhodne in izhodne slike ostanejo enake.</li>
</ul>
<p><strong>Možna rešitev 2: Ocenjevanje manjkajočih vrednosti</strong></p>
<ul>
<li>Manjkajoče pixle si &ldquo;izmislimo&rdquo; oziroma jih ocenimo.</li>
<li>(npr. kopiranje robnih vrednosti, zrcaljenje ipd.)</li>
</ul>
<p><strong>Možna rešitev 3: Brez filtriranja robov</strong></p>
<ul>
<li>
<p>Če pixel nima vseh sosedov okrog sebe, ga ne filtriramo.</p>
</li>
<li>
<p>S tem zmanjšamo dimenzije slike:</p>
<ul>
<li>po vrsticah za $L$</li>
<li>po stolpcih za $K$</li>
</ul>
</li>
</ul>
<p>Slabost:</p>
<ul>
<li>Kljub temu, da je ta rešitev najbolj točna, spremenimo z njo dimenzije slike, kar običajno ni zaželeno.</li>
</ul>
<h6 id="problem-vrednosti-po-filtriranju">
<a class="header-anchor" href="#problem-vrednosti-po-filtriranju"></a>
Problem vrednosti po filtriranju
</h6><p>Po filtriranju dobimo celoštevilčno vrednost, vendar v realnosti dobimo realna (decimalna) števila, ki po vrednosti padejo izven intervala $[0, 255]$. Teoretično to ni problem, problem pa nastane pri vizualizaciji. Takšne slike namreč ne moremo neposredno prikazati.</p>
<p>Za rešitev tega problema se lahko uporabi:</p>
<ol>
<li>Skaliranje vrednosti nazaj v ustrezen interval</li>
<li>Zaokroževanje na celoštevilske vrednosti</li>
</ol>
<h6 id="še-ena-dilema-kje-je-sredina-maske">
<a class="header-anchor" href="#%c5%a1e-ena-dilema-kje-je-sredina-maske"></a>
Še ena dilema: Kje je sredina maske?
</h6><p>Če je dimenzija filtra <strong>liha</strong> (npr. 3×3, 5×5), sredino ni težko določiti. Če pa je filter <strong>sodih dimenzij</strong> (npr. 2×2), pa ni jasno, kaj je sredina maske. Sredino maske poravnamo s pixlom na sliki, vendar kdo določi, kateri element je sredinski?</p>
<p><strong>To mora določiti avtor filtra!</strong></p>
<blockquote>
<p>Primer:</p>
<ul>
<li>Pri filtru 2×2 lahko določimo, da je sredina zgornji desni pixel.</li>
</ul>
</blockquote>
<hr>
<h3 id="odstranjevanje-šuma-z-lokalnimi-operatorji">
<a class="header-anchor" href="#odstranjevanje-%c5%a1uma-z-lokalnimi-operatorji"></a>
Odstranjevanje šuma z lokalnimi operatorji
</h3><p>Šum je moteča komponenta v slikah, ki jo lahko odstranimo s filtri.</p>
<p>Filtri za odstranjevanje šuma zmanjšajo šum, vendar pa vnesejo nove probleme.</p>
<p>Glavni problemi:</p>
<ul>
<li>zapacajo (zabrišejo) robove med regijami na sliki.</li>
<li>robovi med objekti na sliki lahko po filtriranju niso več jasno definirani.</li>
</ul>
<p>Zato moramo vedno uravnotežiti med <strong>pacanjem robov</strong> in <strong>odstranjevanjem šuma</strong>.</p>
<h4 id="nizko-sito-low-pass-filter">
<a class="header-anchor" href="#nizko-sito-low-pass-filter"></a>
Nizko sito (Low-pass filter)
</h4><p>Nizko sito:</p>
<ul>
<li>pusti nizke frekvence pri miru,</li>
<li>visoke frekvence odstrani oziroma zaduši.</li>
</ul>

  <blockquote class="alert-blockquote warning">
    <p class="alert-heading">
      Warning
    </p>
    <p><p>Nizke frekvence NE pomenijo, da imajo piksli nizke vrednosti. Visoke frekvence pa NE pomenijo, da imajo piksli visoke vrednosti. Nizka in visoka frekvenca nista povezani s slikovno funkcijo. Frekvenca ni povezana z absolutno vrednostjo piksla, ampak s hitrostjo spreminjanja slikovne funkcije!</p></p>
  </blockquote>

<h5 id="kaj-pomeni-nizka-frekvenca">
<a class="header-anchor" href="#kaj-pomeni-nizka-frekvenca"></a>
Kaj pomeni nizka frekvenca
</h5><p>Opazujemo, kako se vrednosti slikovne funkcije spreminjajo v prostoru.</p>
<ul>
<li>Če se vrednosti spreminjajo počasi → nizka frekvenca.</li>
<li>Če se vrednosti spreminjajo hitro → visoka frekvenca.</li>
</ul>
<p>Primer nizkih frekvenc:</p>
<ul>
<li>enakomerno obarvana stena,</li>
<li>površina mize (če ni senc ali močnih svetlobnih prehodov),</li>
<li>območja skoraj enakega odtenka.</li>
</ul>
<hr>
<h5 id="kaj-pomeni-visoka-frekvenca">
<a class="header-anchor" href="#kaj-pomeni-visoka-frekvenca"></a>
Kaj pomeni visoka frekvenca?
</h5><p>Visoke frekvence nastopijo:</p>
<ul>
<li>pri detajlih,</li>
<li>pri drobnih strukturah,</li>
<li>na prehodih med različnimi regijami.</li>
</ul>
<p>Primer:</p>
<ul>
<li>prehod iz svetle stene na temno podlago,</li>
<li>rob med dvema objektoma.</li>
</ul>
<p>Takrat slikovna funkcija močno &ldquo;skače&rdquo; po vrednostih.</p>
<hr>
<h5 id="maska-nizkega-sita">
<a class="header-anchor" href="#maska-nizkega-sita"></a>
Maska nizkega sita
</h5><p>Nizko sito običajno vsebuje:</p>
<ul>
<li>masko poljubne dimenzije (npr. 3×3, 5×5, 11×11),</li>
<li>vse vrednosti v maski so enake (npr. same enice),</li>
<li>pred masko je utež za normalizacijo.</li>
</ul>
<p>Primer:</p>
<p>Če imamo masko dimenzije 11×11:</p>
<ul>
<li>ima 121 elementov,</li>
<li>utež pred masko je $\frac{1}{121}$</li>
</ul>
<p>Tak filter izračuna <strong>povprečno vrednost v okolici pixla</strong>.</p>
<hr>
<h4 id="visoko-sito-high-pass-filter">
<a class="header-anchor" href="#visoko-sito-high-pass-filter"></a>
Visoko sito (High-pass filter)
</h4><p>Visoko sito:</p>
<ul>
<li>pusti visoke frekvence pri miru,</li>
<li>zaduši nizke frekvence.</li>
</ul>
<p>Deluje torej ravno obratno kot nizko sito.</p>
<p>Takšni filtri delujejo kot:</p>
<ul>
<li>detektorji robov,</li>
<li>poudarjalci detajlov.</li>
</ul>
<p>Rezultat visokega sita je pogosto večinoma temna slika, z izrazitimi svetlimi točkami ali linijami na mestih robov. Zato rezultat običajno prištejemo ali &ldquo;pritisnemo&rdquo; nazaj na originalno sliko, da poudarimo robove in detajle.</p>
<h4 id="gaussov-filter">
<a class="header-anchor" href="#gaussov-filter"></a>
Gaussov filter
</h4><p>Gre za filter, ki v sliki odstranjuje <strong>bel šum</strong>.</p>
<ul>
<li><strong>Nizko sito</strong> predpostavlja, da so motnje v sliki visoke frekvence.</li>
<li><strong>Visoko sito</strong> predpostavlja, da so problem nizke frekvence.</li>
<li>Pri <strong>gaussovem šumu</strong> pa predpostavimo, da so vse frekvence pokvarjene z nekim deležem.</li>
</ul>
<p>V tem primeru uporabimo <strong>Gaussov filter</strong>.</p>
<p>Gaussov filter nastane iz <strong>Gaussove krivulje</strong>:</p>
$$
G(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{x^2}{2\sigma^2}}
$$<p>Ta krivulja ima parameter:</p>
<ul>
<li>$\sigma$ — standardni odklon</li>
</ul>
<p>Krivuljo rotiramo okoli osi $y$, s čimer dobimo 2D Gaussovo &ldquo;kapo&rdquo;. To kapo nato vzorčimo in dobimo matriko filtra.</p>
<p>Parameter $\sigma$ določa:</p>
<ul>
<li>kako položna ali strma je krivulja,</li>
<li>kako močno bo filter glajenje izvajal.</li>
</ul>
<blockquote>
<p>Primer dveh Gaussovih filtrov:</p>
$$
 H = \frac{1}{16}
 \begin{bmatrix}
 1 & 2 & 1 \\
 2 & 4 & 2 \\
 1 & 2 & 1
 \end{bmatrix}
 $$<p>in</p>
$$
 H = \frac{1}{10}
 \begin{bmatrix}
 1 & 1 & 1 \\
 1 & 2 & 1 \\
 1 & 1 & 1
 \end{bmatrix}
 $$<p>Gre za dva filtra enakih dimenzij, vendar z različnimi vrednostmi. Razlika je v vrednosti $\sigma$ (standardnega odklona).</p>
</blockquote>
<p>Filtrirna moč je odvisna od $\sigma$.</p>
<ul>
<li>
<p>Manjša kot je $\sigma$:</p>
<ul>
<li>manj šuma odstranimo,</li>
<li>upoštevamo manjšo okolico,</li>
<li>filter je ožji.</li>
</ul>
</li>
<li>
<p>Večja kot je $\sigma$:</p>
<ul>
<li>močnejše glajenje,</li>
<li>upoštevamo širšo okolico,</li>
<li>filter postane podoben nizkemu situ.</li>
</ul>
</li>
</ul>
<p>Če je $\sigma$ zelo majhen:</p>
<ul>
<li>skoraj ne upoštevamo sosednjih pixlov,</li>
<li>filter postane skoraj nesmiseln,</li>
<li>pixel praktično množimo sam s seboj.</li>
</ul>
<h4 id="mediani-filter">
<a class="header-anchor" href="#mediani-filter"></a>
Mediani filter
</h4><p>Mediani filter sodi med <strong>rank value filtre</strong>. Gre za filtre, ki sortirajo vrednosti v okolici pixla, nato pa izberejo določeno vrednost iz urejenega seznama. Pri teh filtrih je pomembna okolica pixla, uteži (koeficienti) pa niso pomembne oziroma jih ti filtri ne uporabljajo.</p>
<p>Postopek uporabe <strong>rank value filtrov</strong>:</p>
<ol>
<li>Položimo masko nad pixel, ki ga filtriramo.</li>
<li>NE izvajamo konvolucije.</li>
<li>Vzamemo vse pixle iz okolice.</li>
<li>Vrednosti sortiramo (od najmanjše do največje ali obratno).</li>
<li>Iz sortiranega seznama izberemo določeno vrednost.</li>
</ol>
<p>Primeri rank filtrov</p>
<ul>
<li>
<p><strong>Minimalni filter</strong><br>
→ izberemo najmanjšo vrednost iz okolice.</p>
</li>
<li>
<p><strong>Maksimalni filter</strong><br>
→ izberemo največjo vrednost iz okolice.</p>
</li>
<li>
<p><strong>Median filter</strong><br>
→ izberemo srednji element v sortiranem seznamu (mediano).</p>
</li>
</ul>
<p>Median filter je namenjen odstranjevanju <strong>impulznega šuma</strong>. Impulzni šum pomeni, da je posamezen, izoliran pixel pokvarjen, pojavi se kot nenadna motnja (impulz), pogosto kot zelo svetla ali zelo temna točka.</p>
<ul>
<li>Če je impulznega šuma malo → uporabimo manjši filter (npr. 3×3).</li>
<li>Če je šuma več → potrebujemo večjo masko.</li>
</ul>
<p>Problem median filtra je, da lahko izbriše tanke črte in odstrani drobne detajle v sliki.</p>
<hr>
<h3 id="detektorji-robov">
<a class="header-anchor" href="#detektorji-robov"></a>
Detektorji robov
</h3><p>Filtre lahko uporabljamo tudi za <strong>poudarjanje robov</strong>. Cilj predobdelave slik je med drugim:</p>
<ul>
<li>popravljanje osvetlitve,</li>
<li>odstranjevanje šuma,</li>
<li>poudarjanje pomembnih struktur (npr. robov).</li>
</ul>
<p>Kaj je rob v sliki?
Rob nastane, ko prehajamo iz enega območja slike v drugo, med dvema različnima regijama.</p>
<p>Primer:</p>
<ul>
<li>prehod iz ene barve stene v drugo, kjer je meja med dvema objektoma.</li>
</ul>
<p>Kako se rob kaže v sliki?
Če gledamo slikovno funkcijo se sprehodimo po vrstici pixel po pixel in opazujemo, kako se vrednost funkcije spreminja. Robovi se pojavijo tam, kjer pride do nenadnega skoka v vrednosti slikovne funkcije. Pravi robovi so torej tam, kjer funkcija skoči oz. močno spremeni vrednost.</p>
<p>Slikovna funkcija je funkcija dveh prostorskih koordinat:</p>
$$
f(x, y)
$$<p>Za vsak pixel lahko definiramo <strong>lastnost roba</strong>. Rob je opisan z <strong>vektorsko spremenljivko</strong>:</p>
<ul>
<li>ena komponenta predstavlja jakost roba,</li>
<li>druga komponenta predstavlja smer roba.</li>
</ul>
<p>Da določimo rob, nas zanima, kako hitro se funkcija spreminja. Za dosego tega izračunamo <strong>gradient funkcije</strong>:</p>
$$
\nabla f(x,y) =
\begin{bmatrix}
\frac{\partial f}{\partial x} \\
\frac{\partial f}{\partial y}
\end{bmatrix}
$$<p>Gradient dobimo iz dveh parcialnih odvodov:</p>
<ul>
<li>odvod po $x$ smeri,</li>
<li>odvod po $y$ smeri.</li>
</ul>
<hr>
<h4 id="jakost-roba">
<a class="header-anchor" href="#jakost-roba"></a>
Jakost roba
</h4><p>Jakost roba določimo s pomočjo <strong>jakosti (velikosti) gradienta</strong>:</p>
$$
|\nabla f| =
\sqrt{
\left( \frac{\partial f}{\partial x} \right)^2 +
\left( \frac{\partial f}{\partial y} \right)^2
}
$$<p>Večja kot je vrednost, močnejši je rob.</p>
<hr>
<h4 id="smer-roba">
<a class="header-anchor" href="#smer-roba"></a>
Smer roba
</h4><p>Smer roba je določena s smerjo gradienta. Gradiantni vektor kaže smer največjega in najmanjšega vektorja.</p>
<p><strong>Smer gradienta</strong> lahko določimo z:</p>
$$
\theta = \arctan
\left(
\frac{\partial f / \partial y}
{\partial f / \partial x}
\right)
$$<p>Za vsak pixel izračunamo:</p>
<ul>
<li><strong>jakost roba</strong></li>
<li><strong>smer roba</strong></li>
</ul>
<p>Po izračunu dobimo dve matriki:</p>
<ol>
<li>matriko jakosti robov</li>
<li>matriko smeri robov</li>
</ol>
<p>Prave robove določimo tako, da preverimo ali je jakost roba dovolj velika. Če je jakost premajhna, pixel ne obravnavamo kot rob.</p>
<hr>
<h4 id="gradient-za-zvezno-slikovno-funkcijo">
<a class="header-anchor" href="#gradient-za-zvezno-slikovno-funkcijo"></a>
Gradient za zvezno slikovno funkcijo
</h4><p>Za zvezno funkcijo $I(x,y)$ je gradient definiran kot:</p>
$$
\nabla I =
\begin{bmatrix}
\frac{\partial I}{\partial x} \\
\frac{\partial I}{\partial y}
\end{bmatrix}
$$<p>Jakost roba:</p>
$$
|\nabla I| =
\sqrt{
\left(\frac{\partial I}{\partial x}\right)^2 +
\left(\frac{\partial I}{\partial y}\right)^2
}
$$<p>Smer roba:</p>
$$
\theta =
\arctan
\left(
\frac{\frac{\partial I}{\partial y}}
{\frac{\partial I}{\partial x}}
\right)
$$<hr>
<h4 id="aproksimacija-parcialnih-odvodov-v-digitalnih-slikah">
<a class="header-anchor" href="#aproksimacija-parcialnih-odvodov-v-digitalnih-slikah"></a>
Aproksimacija parcialnih odvodov v digitalnih slikah
</h4><p>Ker so digitalne slike diskretne, moramo parcialne odvode <strong>aproksimirati z razlikami</strong>.</p>
<h5 id="aproksimacija-odvoda-po-x">
<a class="header-anchor" href="#aproksimacija-odvoda-po-x"></a>
Aproksimacija odvoda po x
</h5><p>Za diskretno sliko $I(i,j)$:</p>
<p><strong>Razlika nazaj:</strong></p>
$$
\frac{\partial I(i,j)}{\partial x}
\approx
\frac{I(i,j) - I(i-\Delta x, j)}{\Delta x}
$$<p><strong>Razlika naprej:</strong></p>
$$
\frac{\partial I(i,j)}{\partial x}
\approx
\frac{I(i+\Delta x, j) - I(i,j)}{\Delta x}
$$<p><strong>Simetrična razlika:</strong></p>
$$
\frac{\partial I(i,j)}{\partial x}
\approx
\frac{I(i+\Delta x, j) - I(i-\Delta x, j)}{2\Delta x}
$$<p>Običajno vzamemo:</p>
$$
\Delta x = 1
$$<p>Podobno velja za odvod po $y$ smeri.</p>
<hr>
<h4 id="laplaceov-operator">
<a class="header-anchor" href="#laplaceov-operator"></a>
Laplaceov operator
</h4><p>Laplaceov operator uporabimo za oceno <strong>drugega odvoda</strong> slikovne funkcije.</p>
<p>Za zvezno funkcijo $I(x,y)$ je definiran kot:</p>
$$
\nabla^2 I =
\frac{\partial^2 I}{\partial x^2}
+
\frac{\partial^2 I}{\partial y^2}
$$<p>V digitalni sliki ga aproksimiramo z masko (konvolucijskim filtrom), npr.:</p>
$$
\begin{bmatrix}
0 & -1 & 0 \\
-1 & 4 & -1 \\
0 & -1 & 0
\end{bmatrix}
$$<p>Rezultat je matrika, v kateri je ocenjen približek za <strong>drugi odvod</strong> slike.</p>
<hr>
<h4 id="sobelov-operator">
<a class="header-anchor" href="#sobelov-operator"></a>
Sobelov operator
</h4><p>Sobelov operator uporabljamo za oceno <strong>prvih parcialnih odvodov</strong> (gradienta).</p>
<p>Uporabimo dve maski:</p>
<p><strong>Maska $H_x$ (odvod po x)</strong></p>
$$
H_x =
\begin{bmatrix}
-1 & 0 & 1 \\
-2 & 0 & 2 \\
-1 & 0 & 1
\end{bmatrix}
$$<p>Z njo dobimo ocenjen parcialni odvod po $x$:</p>
$$
G_x = I * H_x
$$<p><strong>Maska $H_y$ (odvod po y)</strong></p>
<p>Masko dobimo z rotacijo za 90°:</p>
$$
H_y =
\begin{bmatrix}
-1 & -2 & -1 \\
0 & 0 & 0 \\
1 & 2 & 1
\end{bmatrix}
$$<p>Z njo dobimo ocenjen parcialni odvod po $y$:</p>
$$
G_y = I * H_y
$$<hr>
<h5 id="jakost-in-smer-gradienta">
<a class="header-anchor" href="#jakost-in-smer-gradienta"></a>
Jakost in smer gradienta
</h5><p>Jakost gradienta:</p>
$$
|\nabla I| =
\sqrt{G_x^2 + G_y^2}
$$<p>Smer gradienta:</p>
$$
\psi =
\arctan\left(\frac{G_y}{G_x}\right)
$$<hr>
<p>Digitalne slike niso samo črno-bele, ampak imajo <strong>sivinske vrednosti</strong>:</p>
<ul>
<li>temnejši del slike → manjša vrednost</li>
<li>svetlejši del slike → večja vrednost</li>
<li>črna → vrednost blizu 0</li>
<li>bela → največja vre</li>
</ul>
<p>&ndash;</p>
<h2 id="segmentacija-slik">
<a class="header-anchor" href="#segmentacija-slik"></a>
Segmentacija slik
</h2><h3 id="pragovna-operacija">
<a class="header-anchor" href="#pragovna-operacija"></a>
Pragovna operacija
</h3><h4 id="segmentacija">
<a class="header-anchor" href="#segmentacija"></a>
Segmentacija
</h4><p>Pri segmentaciji je cilj, da sliko razdelimo na <strong>regije</strong>:</p>
<ul>
<li>regija 1</li>
<li>regija 2</li>
<li>regija 3</li>
<li>&hellip;</li>
</ul>
<p>Te regije tvorijo piksli, ki so si med seboj podobni glede na nek kriterij, ki ga določimo, na primer:</p>
<ul>
<li>sivinska vrednost</li>
<li>barva</li>
<li>gradient</li>
<li>tekstura</li>
<li>itd.</li>
</ul>
<hr>
<p>Regija mora biti <strong>sklenjena</strong>. To pomeni, da lahko znotraj regije od enega pixla do drugega pridemo brez &ldquo;skakanja&rdquo; izven regije.</p>
<p>Unija vseh regij mora pokriti vse pixle v sliki.</p>
<p>Vedno imamo najmanj <strong>dve regiji</strong>:</p>
<ol>
<li><strong>Region of Interest (ROI)</strong> – regija, ki nas zanima</li>
<li><strong>Background</strong> – regija, ki nas ne zanima</li>
</ol>
<p>Pri vsakem problemu imamo torej vsaj eno regijo, ki nas zanima, in eno, ki nas ne zanima.<br>
Koliko dodatnih regij imamo, je odvisno od problema, ki ga rešujemo.</p>
<blockquote>
<p>Primer
Če bi analizirali študente po obrazu:</p>
<ul>
<li>obraz študenta → regija, ki nas zanima</li>
<li>vse ostalo → background</li>
</ul>
</blockquote>
<hr>
<p>Piksli v regijah imajo <strong>labelo (oznako)</strong>.</p>
<ul>
<li>Piksli v isti regiji imajo isto labelo (isto številko).</li>
<li>Pikslom, ki nas ne zanimajo (background), nastavimo labelo <strong>0</strong>.</li>
<li>Tisto, kar nas zanima, ima vrednost <strong>večjo od 0</strong>.</li>
</ul>

  <blockquote class="alert-blockquote warning">
    <p class="alert-heading">
      Warning
    </p>
    <p><p>Labele niso nujno zaporedne! Na primer: vsi pixli neke regije imajo lahko vrednost 103.</p></p>
  </blockquote>

<hr>
<p>Pri segmentaciji bo naš vhod <strong>sivinska slika</strong>, na izhodu segmentacije pa bomo dobili ven <strong>segmentirano sliko</strong>.</p>
<p>Segmentirana slika je lahko <strong>Binarna slika</strong>. Pri binarni sliki velja:</p>
<ul>
<li>vrednost 0 → background (nas ne zanima)</li>
<li>vrednost ≠ 0 → objekt/regija, ki nas zanima</li>
</ul>
<hr>
<p>Sivinska slika pa lahko vsebuje več regij, ki nas zanimajo (npr. več objektov z določeno sivinsko vrednostjo).</p>

  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p>Cilj segmentacije je, da dobimo regijo, ki čim bolje ustreza objektu, ki nas zanima.</p></p>
  </blockquote>

<p>Poznamo 2 vrsti segmentacij, <strong>popolno segmentacijo</strong> in <strong>delno segmentacijo</strong>.</p>

  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p><strong>Popolna segmentacija</strong> pomeni, da natančno dobimo objekt, ki ga iščemo brez dodatnih ali manjkajočih delov.</p></p>
  </blockquote>


  <blockquote class="alert-blockquote important">
    <p class="alert-heading">
      Important
    </p>
    <p><p>V praksi pa so pogostejše <strong>delne segmentacije</strong>. Pri tej vrsti segmentacij dobimo poleg objekta, ki nas zanima, tudi dodatne neželene dele in regije, kjer se pojavijo napake.</p></p>
  </blockquote>


  <blockquote class="alert-blockquote warning">
    <p class="alert-heading">
      Warning
    </p>
    <p><p>NI UNIVERZALNE SEGMENTACIJSKE METODE ZA REŠEVANJE VSAKEGA PROBLEMA! ENE EDINSTSTVENE METODE NI! METODO PRILAGODIMO GLEDE NA NAŠ PROBLEM, KI GA REŠUJEMO.</p></p>
  </blockquote>

<hr>
<h4 id="segmentacijske-metode">
<a class="header-anchor" href="#segmentacijske-metode"></a>
Segmentacijske metode
</h4><p>Segmentacijske metode lahko razdelimo v različne skupine. Metode delimo glede na <strong>informacijo</strong>, ki jo uporabljajo za segmentacijo. Ločimo 3 skupine segmentacijskih metod, in sicer glede na dominantno lastnost, ki jo uporabljajo.</p>
<p>Ločimo sledeče 3 skupine segmentacijskih metod:</p>
<ul>
<li><strong>segmentacija z globalnim znanjem o sliki oz. njenih delih</strong> (npr. pragodvna operacija).</li>
<li><strong>segmentacija na osnovi robov</strong></li>
<li><strong>segmentacija na osnovi regij</strong></li>
</ul>
<p>(segmentacija na osnovi robov in osnovi regij delata isto stvar na 2 različna načina. Pomenita dualni problem: vsaka regija je namreč lahko predstavljena s sklenjeno konturo in obratno)</p>
<ul>
<li><strong>učeče metode (sodobni pristopi)</strong></li>
</ul>
<p><strong>Učeči pristopi</strong> postajajo v zadnjih letih popularni. Sem sodijo:</p>
<ul>
<li>strojno učenje</li>
<li>globoko učenje</li>
<li>nevronske mreže</li>
</ul>
<p>Model se nauči segmentacije iz podatkov. Pri tem imamo nek model (npr. obliko ali strukturo)<br>
in se vprašamo:</p>
<blockquote>
<p>Ali ta model obstaja v sliki?</p>
</blockquote>
<p>Segmentacija temelji na preverjanju ujemanja med modelom in dejansko sliko.</p>
<h5 id="thresholding-pragovna-operacija">
<a class="header-anchor" href="#thresholding-pragovna-operacija"></a>
Thresholding (Pragovna operacija)
</h5><p>Thresholding je <strong>najhitrejši način segmentacije</strong>. Zaradi svoje enostavnosti in hitrosti je zelo primeren za real-time aplikacije. Imamo en prag $T$. Vsak piksel slike po vrsticah in stolpcih primerjamo s tem pragom. Za vsak piksel $I(i,j)$:</p>
$$
g(i,j) =
\begin{cases}
1, & \text{če } I(i,j) \geq T \\
0, & \text{sicer}
\end{cases}
$$<p>Najenostavnejše so operacije z enim pragom in da je ta prag konstanten za celotno sliko.</p>
<p>Algoritem:</p>
<ul>
<li>na začetku določimo prag (npr. $T = 87$),</li>
<li>z dvema for zankama (po vrsticah in stolpcih) pregledamo vse piksle,</li>
<li>vsak piksel primerjamo s pragom,</li>
<li>če je vrednost piksla večja ali enaka določenemu pragu (npr. $T = 87$), potem vrnemo vrednost 1, sicer vrnemo vrednost 0</li>
</ul>
<h5 id="variabilni-prag-lokalni-thresholding">
<a class="header-anchor" href="#variabilni-prag-lokalni-thresholding"></a>
Variabilni prag (lokalni thresholding)
</h5><p>Če je prag variabilen se prag prilagaja glede na del slike in metoda postane zahtevnejša. V praksi ne računamo popolnoma neodvisnega praga za vsak pixel, ampak prag določimo na lokalnem območju (npr. v oknu okoli pixla).</p>
<p>Če iščemo svetle objekte na temnem ozadju:</p>
$$
I(i,j) \geq T
$$<p>Če pa iščemo temne objekte na svetlem ozadju, obrnemo neenačaj:</p>
$$
I(i,j) \leq T
$$<hr>
<p>Trashholding je danes zelo pogosto uporabljen. Uporablja se skoraj v vseh industrijskih aplikacijah, kjer:</p>
<ul>
<li>imamo nadzor nad osvetlitvijo,</li>
<li>so pogoji zajema slike stabilni,</li>
<li>je kontrast med objektom in ozadjem dovolj velik.</li>
</ul>
<p>Če lahko nadzorujemo svetlobo, je thresholding pogosto najboljša izbira.</p>
<hr>
<p>Namesto enega praga pa lahko uporabimo tudi več pragov:</p>
$$
T_1 < T_2 < T_3 < \dots
$$<p>Pixel razvrstimo glede na interval, v katerega pade njegova vrednost.</p>
<p>Primer:</p>
$$
g(i,j) =
\begin{cases}
0, & I < T_1 \\
1, & T_1 \leq I < T_2 \\
2, & T_2 \leq I < T_3 \\
\dots
\end{cases}
$$<p>Rezultat:</p>
<ul>
<li>več-regijska segmentacija</li>
<li>ne samo binarna slika</li>
</ul>
<hr>
<h5 id="kako-določiti-prag">
<a class="header-anchor" href="#kako-dolo%c4%8diti-prag"></a>
Kako določiti prag?
</h5><p>Metoda je zelo preprosta. Glavni problem pa je kako pravilno določiti prag. Izbira praga je namreč ključna za uspešno segmentacijo.</p>
<p>Če imamo 8-bitno sivinsko sliko, imajo pixli vrednosti od:</p>
$$
0 \text{ do } 255
$$<p>To pomeni, da imamo teoretično <strong>256 možnih pragov</strong>.</p>
<p>Vprašanje je:</p>
<blockquote>
<p>Kateri prag je pravi?</p>
</blockquote>
<p>Odgovor ni enoznačen.</p>
<p>Ne obstaja univerzalno najboljša segmentacijska metoda, ki bi vedno vrnila pravi prag.<br>
Izbira praga je vedno odvisna od problema, ki ga rešujemo.</p>
<ul>
<li>En prag je lahko za en problem perfekten.</li>
<li>Za drug problem pa popolnoma neuporaben.</li>
</ul>
<h6 id="1-eksperimentalna-določitev">
<a class="header-anchor" href="#1-eksperimentalna-dolo%c4%8ditev"></a>
1. Eksperimentalna določitev
</h6><p>Prag določimo ročno. To pomeni, da si prag sami izmislimo. Kontroliramo okolje, mi zajamemo slike, primerjamo in testiramo kateri prag je najboljši in tistega uporabimo.</p>
<hr>
<h6 id="2-polovica-med-minimalno-in-maksimalno-sivino-na-sliki">
<a class="header-anchor" href="#2-polovica-med-minimalno-in-maksimalno-sivino-na-sliki"></a>
2. Polovica med minimalno in maksimalno sivino na sliki
</h6><p>Vzememo:</p>
<ul>
<li>najmanjšo sivinsko vrednost v sliki: $I_{min}$</li>
<li>največjo sivinsko vrednost v sliki: $I_{max}$</li>
</ul>
<p>Prag določimo tako, da vzamemo največjo in najmanjšo vrednost na sliki in vzamemo sredino za prag:</p>
$$
T = \frac{I_{min} + I_{max}}{2}
$$<p>Metoda je preprosta, vendar pogosto ni optimalna.</p>
<hr>
<p>Za naprednejše metode potrebujemo določiti nekaj pomožnih izrazov iz slike I:</p>
<ol>
<li>histogram sivin</li>
<li>dve pomožni polji</li>
</ol>
<p>Naj ima histogram $L$ elementov (pri 8-bitni sliki je $L = 256$).</p>
<p>Označimo:</p>
<ul>
<li>$h_k$ → število pikslov s sivinsko vrednostjo $k$</li>
</ul>
<hr>
<p><strong>Pomožno polje</strong></p>
<p>Polje $A$ ima enako število elementov kot histogram.</p>
<p>V njem hranimo kumulativno vsoto števila pikslov do nivoja $k$:</p>
$$
A_k = \sum_{i=0}^{k} h_i
$$<p>To pomeni:</p>
<ul>
<li>$A_0 = h_0$</li>
<li>$A_1 = h_0 + h_1$</li>
<li>$A_2 = h_0 + h_1 + h_2$</li>
<li>&hellip;</li>
<li>$A_k = \sum_{i=0}^{k} h_i$</li>
</ul>
<p>Polje $A_k$ nam pove, koliko pixlov ima sivinsko vrednost manjšo ali enako $k$.</p>
<hr>
<p><strong>Pomožno polje B</strong></p>
<p>Polje $B$ ima prav tako enako število elementov kot histogram.</p>
<p>V njem hranimo kumulativno vsoto sivinskih vrednosti:</p>
$$
B_k = \sum_{i=0}^{k} i \cdot h_i
$$<p>Primeri:</p>
<ul>
<li>$B_0 = 0 \cdot h_0$</li>
<li>$B_1 = 0 \cdot h_0 + 1 \cdot h_1$</li>
<li>$B_2 = 0 \cdot h_0 + 1 \cdot h_1 + 2 \cdot h_2$</li>
</ul>
<p>Na splošno:</p>
<p>Vsak element vsebuje vsoto:</p>
<blockquote>
<p>sivina × število pixlov (za vse sivine ≤ k)</p>
</blockquote>
<ul>
<li>$B_k$ hrani vsoto vseh sivinskih vrednosti, ki so manjše ali enake $k$.</li>
<li>Zadnji element $B_{L-1}$ predstavlja vsoto vseh sivinskih vrednosti v celotni sliki.</li>
</ul>
<p>To sta osnovni pomožni polji, ki ju uporabljamo pri naprednejših metodah določanja praga (npr. optimizacijskih metodah).</p>
<hr>
<h6 id="3prag-kot-povprečje-slike">
<a class="header-anchor" href="#3prag-kot-povpre%c4%8dje-slike"></a>
3.Prag kot povprečje slike
</h6><p>Prag postavimo na <strong>povprečno sivinsko vrednost slike</strong>.</p>
<p>Izračun:</p>
$$
T = \frac{\text{vsota vseh sivinskih vrednosti}}{\text{število vseh pixlov}}
$$<p>Ker že imamo definirani pomožni polji:</p>
<ul>
<li>$A_Q$ → skupno število vseh pixlov</li>
<li>$B_Q$ → vsota vseh sivinskih vrednosti v sliki</li>
</ul>
<p>Lahko prag izračunamo kot:</p>
$$
T = \frac{B_Q}{A_Q}
$$<p>Dobimo aritmetično sredino (povprečje) sivinskih vrednosti.</p>
<p>Ta metoda je preprosta, vendar:</p>
<ul>
<li>deluje dobro le, če je histogram približno simetričen,</li>
<li>ni nujno optimalna za slike z več vrhovi v histogramu.</li>
</ul>
<hr>
<h6 id="4-prag-kot-mediana">
<a class="header-anchor" href="#4-prag-kot-mediana"></a>
4. Prag kot mediana
</h6><p>Prag določimo z <strong>mediano histogramov sivin</strong>.</p>
<p>Prag postavimo tako, da:</p>
<ul>
<li>približno polovica pixlov ima vrednost manjšo od praga,</li>
<li>približno polovica pixlov ima vrednost večjo od praga.</li>
</ul>
<p>Formalno:</p>
<p>Poiščemo tak $T$, da velja:</p>
$$
A_T \approx \frac{A_Q}{2}
$$<p>kjer je:</p>
<ul>
<li>$A_T$ → kumulativno število pixlov do sivine $T$</li>
<li>$A_Q$ → skupno število vseh pixlov</li>
</ul>
<hr>
<ol>
<li>Izračunamo histogram.</li>
<li>Izračunamo kumulativno polje $A_k$.</li>
<li>S pomočjo zanke (npr. <code>for</code>) pregledujemo vse možne pragove.</li>
<li>Ustavimo se pri prvem $T$, kjer:</li>
</ol>
$$
A_T \geq \frac{A_Q}{2}
$$<p>Ta $T$ je mediana sivinskih vrednosti.</p>
<hr>
<h6 id="5-optimalni-prag-iterativna-metoda">
<a class="header-anchor" href="#5-optimalni-prag-iterativna-metoda"></a>
5. Optimalni prag (iterativna metoda)
</h6>
  <blockquote class="alert-blockquote warning">
    <p class="alert-heading">
      Warning
    </p>
    <p><p>Kljub imenu ta metoda <strong>ni matematično optimalna</strong> v splošnem smislu! Deluje dobro le, če so izpolnjene določene predpostavke o porazdelitvi sivinskih vrednosti.</p></p>
  </blockquote>

<p>Pri globalnem pragu običajno predpostavimo:</p>
<ul>
<li>en del slike predstavlja <strong>ozadje</strong>,</li>
<li>drugi del slike predstavlja <strong>objekt (kar nas zanima)</strong>.</li>
</ul>
<p>V histogramu sivinskih vrednosti imamo torej dve porazdelitvi:</p>
<ul>
<li>ena pripada ozadju (npr. zelena krivulja),</li>
<li>druga pripada objektu (npr. rdeča krivulja).</li>
</ul>
<p>V praksi poznamo samo skupni histogram, ki je vsota obeh porazdelitev.</p>
<p><strong>Cilj metode je najti prag, ki najbolje loči ti dve porazdelitvi.</strong></p>
<hr>
<p>Metoda je <strong>iterativna</strong>.</p>
<p>Potrebujemo:</p>
<ul>
<li>začetni približek praga $T_0$ (<strong>Začetni prag določimo sami!</strong>)</li>
</ul>
<hr>
<p>Pri pragu $T_0$:</p>
<ul>
<li>vse sivine manjše od $T_0$ obravnavamo kot ozadje,</li>
<li>vse sivine večje ali enake $T_0$ obravnavamo kot objekt.</li>
</ul>
<p>Izračunamo:</p>
<ul>
<li>povprečno vrednost ozadja → $\mu_0(T_0)$</li>
<li>povprečno vrednost objekta → $\mu_1(T_0)$</li>
</ul>
<hr>
<p>Nov prag določimo kot sredino med obema povprečjema:</p>
$$
T_{1} = \frac{\mu_0(T_0) + \mu_1(T_0)}{2}
$$<hr>
<p>Postopek ponavljamo:</p>
<ol>
<li>Razdelimo histogram glede na trenutni prag $T_k$.</li>
<li>Izračunamo:
<ul>
<li>$\mu_0(T_k)$</li>
<li>$\mu_1(T_k)$</li>
</ul>
</li>
<li>Posodobimo prag:</li>
</ol>
$$
T_{k+1} = \frac{\mu_0(T_k) + \mu_1(T_k)}{2}
$$<hr>
<p>Iteracije izvajamo, dokler se prag bistveno spreminja.</p>
<p>Razliko merimo z majhno konstanto $\varepsilon$:</p>
$$
|T_{k+1} - T_k| < \varepsilon
$$<p>Ker delamo z realnimi števili, se prag običajno vedno nekoliko spremeni, zato potrebujemo toleranco $\varepsilon$.</p>
<hr>
<h6 id="6-globalni-prag-določen-z-entropijo-kapurjev-prag">
<a class="header-anchor" href="#6-globalni-prag-dolo%c4%8den-z-entropijo-kapurjev-prag"></a>
6. Globalni prag določen z entropijo (Kapurjev prag)
</h6><p>Ta metoda določi prag na podlagi <strong>entropije</strong>. Entropija je mera za količino informacije v sistemu.</p>
<p>Slika vsebuje malo informacij, če imajo vsi pixli enako ali zelo podobno sivinsko vrednost in je histogram močno skoncentriran okoli ene vrednosti.</p>
<p>Primer:</p>
<ul>
<li>vsi pixli imajo isto sivino → entropija je minimalna.</li>
</ul>
<hr>
<p>Slika vsebuje veliko informacij, če so zastopane vse sivinske vrednosti in so vrednosti približno naključno porazdeljene. Takrat je entropija visoka.</p>
<hr>
<p><strong>Ideja Kapurjeve metode</strong></p>
<p>Imamo izbran prag $T$, ki sliko razdeli na:</p>
<ul>
<li><strong>ozadje</strong> (sivine ≤ T)</li>
<li><strong>ospredje</strong> (sivine &gt; T)</li>
</ul>
<p>Cilj:</p>
<blockquote>
<p>Po segmentaciji želimo ohraniti čim več informacij v obeh delih slike.</p>
</blockquote>
<p>Postopek:</p>
<ul>
<li>izračunamo entropijo ozadja,</li>
<li>izračunamo entropijo ospredja,</li>
<li>seštejemo obe entropiji.</li>
</ul>
<p>Naj bo:</p>
<ul>
<li>$p_i$ → normaliziran histogram (verjetnost sivine $i$)</li>
</ul>
<p><strong>Za izbran prag $T$</strong>:</p>
<p><strong>Entropija ozadja</strong>:
</p>
$$
H_0(T)
$$<p><strong>Entropija ospredja</strong>:
</p>
$$
H_1(T)
$$<p><strong>Skupna entropija</strong>:
</p>
$$
H(T) = H_0(T) + H_1(T)
$$<hr>
<p><strong>Postopek</strong>:</p>
<ol>
<li>Izračunamo histogram.</li>
<li>Histogram normaliziramo (da dobimo verjetnosti).</li>
<li>Z zanko (<code>for</code>) pregledamo vse možne prage:
<ul>
<li>od 0 do 255 (pri 8-bitni sliki).</li>
</ul>
</li>
<li>Za vsak prag izračunamo:
<ul>
<li>entropijo ozadja,</li>
<li>entropijo ospredja,</li>
<li>njuno vsoto.</li>
</ul>
</li>
<li>Poiščemo prag, kjer je vrednost:$H(T) \text{ maksimalna}$</li>
</ol>
<p>Naš prag je tam, kjer dobimo naksimalne vrednosti.</p>
<hr>
<h3 id="pragovna-operacija-na-sliki-robov">
<a class="header-anchor" href="#pragovna-operacija-na-sliki-robov"></a>
Pragovna operacija na sliki robov
</h3><p>Najenostavnejši pristop:</p>
<ol>
<li>Na sivinski sliki uporabimo <strong>detektor robov</strong>.</li>
<li>Dobimo sliko jakosti robov.</li>
<li>Na tej sliki izvedemo <strong>thresholding (pragovanje)</strong>.</li>
</ol>
<p>Rezultat:</p>
<ul>
<li>piksli, ki predstavljajo rob → vrednost 1</li>
<li>ostali piksli → vrednost 0</li>
</ul>
<hr>
<p>Po thresholdingu dobimo robove objekta. Te robove pa moramo med seboj povezati v smiselne konture. Samo binarna slika robov še ne pomeni, da imamo zaključene meje regij.</p>
<p>Algoritem sledenja meji:</p>
<ul>
<li>poveže robne piksle v zaprto konturo,</li>
<li>ali pa iz že znane regije poišče njen rob.</li>
</ul>
<p>Uporabimo ga lahko:</p>
<ul>
<li>ko še nimamo definirane regije (povezujemo robove),</li>
<li>ali ko regijo že imamo (iščemo njen obris).</li>
</ul>
<hr>
<h4 id="notranja-in-zunanja-meja-regije">
<a class="header-anchor" href="#notranja-in-zunanja-meja-regije"></a>
Notranja in zunanja meja regije
</h4><h5 id="notranja-meja">
<a class="header-anchor" href="#notranja-meja"></a>
Notranja meja
</h5><p>Notranjo mejo tvorijo:</p>
<ul>
<li>pixli, ki še pripadajo regiji,</li>
<li>in se nahajajo na njenem robu.</li>
</ul>
<p>Ko govorimo o <strong>obrisu regije</strong>, mislimo na notranjo mejo.</p>
<hr>
<h5 id="zunanja-meja">
<a class="header-anchor" href="#zunanja-meja"></a>
Zunanja meja
</h5><p>Zunanjo mejo tvorijo:</p>
<ul>
<li>pixli, ki so sosedi notranje meje,</li>
<li>vendar ne pripadajo regiji,</li>
<li>ampak ozadju ali drugi regiji.</li>
</ul>

  <blockquote class="alert-blockquote warning">
    <p class="alert-heading">
      Warning
    </p>
    <p><p>Regija ne sme biti velika samo 1 pixel. Če dobimo regijo velikosti 1 pixel, smo najverjetneje naredili napako v segmentaciji.</p></p>
  </blockquote>

<hr>
<h5 id="kako-deluje-algoritem-sledenja-meji">
<a class="header-anchor" href="#kako-deluje-algoritem-sledenja-meji"></a>
Kako deluje algoritem sledenja meji?
</h5><p>Ključno vprašanje:</p>
<blockquote>
<p>Kakšno sosedstvo uporabimo?</p>
</blockquote>
<h6 id="4-sosedstvo">
<a class="header-anchor" href="#4-sosedstvo"></a>
4-sosedstvo
</h6><p>Pixel ima 4 sosede:</p>
<ul>
<li>gor</li>
<li>dol</li>
<li>levo</li>
<li>desno</li>
</ul>
<h6 id="8-sosedstvo">
<a class="header-anchor" href="#8-sosedstvo"></a>
8-sosedstvo
</h6><p>Pixel ima 8 možnih smeri gibanja:</p>
<ul>
<li>gor</li>
<li>dol</li>
<li>levo</li>
<li>desno</li>
<li>štiri diagonalne smeri</li>
</ul>
<p>Pri 8-sosedstvu se lahko iz posameznega pixla premaknemo v 8 različnih smeri. To omogoča bolj naravno in neprekinjeno sledenje robov.</p>
<h3 id="ujemanje-šablon">
<a class="header-anchor" href="#ujemanje-%c5%a1ablon"></a>
Ujemanje šablon
</h3></div>
    <footer class="article-footer"><ul class="article-category-list"></ul>
<ul class="article-tag-list" itemprop="keywords"></ul>
</footer>
  </div><nav
    id="article-nav"
    aria-label="Article navigation"
    data-aos="fade-up"
  ><div class="article-nav-link-wrap left"><img
              data-src="https://d-sketon.top/img/_backwebp/bg1.webp"
              data-sizes="auto"
              alt="Hello World"
              class="lazyload"
            /><a
          href="/post/hello/"
          aria-label="Prev:Hello World"
          title="Prev:Hello World"
        ></a>
        <div class="article-nav-caption">Prev</div>
        <h3 class="article-nav-title">Hello World</h3>
      </div></nav></article></section>
        </div><footer id="footer" aria-label="Site footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info"><div>
      <span class="icon-copyright"></span>2020-2026<span class="footer-info-sep rotate"></span>PrincessSarmica
    </div><div>
        Powered by&nbsp;<a
          href="https://gohugo.io/"
          target="_blank"
          rel="noopener nofollow noreferrer"
          >Hugo</a
        >&nbsp;Theme.<a
          href="https://github.com/D-Sketon/hugo-theme-reimu"
          target="_blank"
          rel="noopener nofollow noreferrer"
          >Reimu</a
        >
      </div><div>
        <span class="icon-brush"
          >&nbsp;11.3k</span
        >
        &nbsp;|&nbsp;
        <span class="icon-coffee">&nbsp;00:55</span>
      </div><div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv"
          >Number of visits&nbsp;<span
            id="busuanzi_value_site_pv"
          ></span
        ></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv"
          >Number of visitors&nbsp;<span
            id="busuanzi_value_site_uv"
          ></span
        ></span>
      </div></div>
</footer>
<div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div><div id="mask" class="hide"></div>
      </div><nav id="mobile-nav" aria-label="Mobile navigation">
  <div class="sidebar-wrap"><div class="sidebar-toc-sidebar"><h3 class="toc-title">Contents</h3>
<div class="sidebar-toc-wrapper toc-div-class">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#uvod-v-računalniški-vid">Uvod v računalniški vid</a>
      <ul>
        <li><a href="#osnovni-pojmi">Osnovni pojmi</a></li>
        <li><a href="#uporabljene-oznake">Uporabljene oznake</a></li>
        <li><a href="#operacije-nad-slikami">Operacije nad slikami</a></li>
      </ul>
    </li>
    <li><a href="#model-kamere-in-zajemanje-slik">Model kamere in zajemanje slik</a>
      <ul>
        <li><a href="#zajemanje-slik-s-kamerami-ccd">Zajemanje slik s kamerami CCD</a></li>
        <li><a href="#modeli-kamer">Modeli kamer</a></li>
        <li><a href="#parametri-kamere">Parametri kamere</a></li>
        <li><a href="#geometrijsko-kalibriranje-kamer">Geometrijsko kalibriranje kamer</a></li>
      </ul>
    </li>
    <li><a href="#predobdelava-slik">Predobdelava slik</a>
      <ul>
        <li><a href="#spreminajnje-kontrasta">Spreminajnje kontrasta</a></li>
        <li><a href="#lokalne-operacije-oz-filtriranje-slik">Lokalne operacije oz. filtriranje slik</a></li>
        <li><a href="#odstranjevanje-šuma-z-lokalnimi-operatorji">Odstranjevanje šuma z lokalnimi operatorji</a></li>
        <li><a href="#detektorji-robov">Detektorji robov</a></li>
      </ul>
    </li>
    <li><a href="#segmentacija-slik">Segmentacija slik</a>
      <ul>
        <li><a href="#pragovna-operacija">Pragovna operacija</a></li>
        <li><a href="#pragovna-operacija-na-sliki-robov">Pragovna operacija na sliki robov</a></li>
        <li><a href="#ujemanje-šablon">Ujemanje šablon</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div></div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img
    data-src="/avatar/../images/avatar/avatar.webp"
    data-sizes="auto"
    alt="PrincessSarmica"
    class="lazyload"
  />
  <div class="sidebar-author-name">PrincessSarmica</div>
  <div class="sidebar-description">Notes of a delusional programmer</div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>Posts</div><div class="sidebar-state-number">2</div>
  </div>
  <a class="sidebar-state-category" href="/categories/" aria-label="sidebar-state-category-link">
    <div>Categories</div>
    <div class="sidebar-state-number">
      0
    </div>
  </a>
  <a class="sidebar-state-tag" href="/tags/" aria-label="sidebar-state-tag-link">
    <div>Tags</div>
    <div class="sidebar-state-number">0</div>
  </a>
</div>
<div class="sidebar-social" ><div class="icon-github sidebar-social-icon">
      <a
        href="https://github.com/princesssarmica"
        itemprop="url"
        target="_blank"
        aria-label="github"
        rel="noopener nofollow noreferrer"
      ></a>
    </div></div><div class="sidebar-menu"><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/"
        aria-label="Home"
      ></a><div class='sidebar-menu-icon icon '>&#xe3af;</div><div class="sidebar-menu-link">Home</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/archives"
        aria-label="Archives"
      ></a><div class='sidebar-menu-icon icon '>&#xf187;</div><div class="sidebar-menu-link">Archives</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/about"
        aria-label="About"
      ></a><div class='sidebar-menu-icon icon '>&#xf05a;</div><div class="sidebar-menu-link">About</div>
    </div><div class="sidebar-menu-link-wrap">
      <a
        class="sidebar-menu-link-dummy"
        href="/friend"
        aria-label="Friend"
      ></a><div class='sidebar-menu-icon icon '>&#xf500;</div><div class="sidebar-menu-link">Friend</div>
    </div></div></div></div><div class="sidebar-btn-wrapper">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div></nav>
</div><script
    src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js"
    
    
    
    
    integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e" crossorigin="anonymous"></script><script
    src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js"
    
    
    
    
    integrity="sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script><script
    src="https://npm.webcache.cn/material-theme@1.0.0/dist/material-theme.umd.js"
    
    
    
    
    integrity="sha384-vLev0II0HKFaxkcm&#43;/7kX5IGwVFBASkGchU311wmU/veIj2bB0UcBkQbW6yw2asK" crossorigin="anonymous"></script><script src="/js/main.js" integrity="" crossorigin="anonymous"  ></script><script src="/js/aos.js" integrity="" crossorigin="anonymous"  ></script><script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", aosInit);
    } else {
      aosInit();
    }
  </script><script src="/js/pjax_main.js" integrity="" crossorigin="anonymous" data-pjax ></script><script>
  var setupFirework = () => {
    if (! false  || !window.matchMedia('(max-width: 768px)').matches) {
      if (window.firework) {
        const options = JSON.parse("{\"excludeelements\":[\"a\",\"button\"],\"particles\":[{\"colors\":[\"var(--red-1)\",\"var(--red-2)\",\"var(--red-3)\",\"var(--red-4)\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"emit\"],\"number\":20,\"shape\":\"polygon\",\"shapeOptions\":{\"alpha\":[0.3,0.5],\"radius\":[16,32],\"sides\":3}},{\"colors\":[\"var(--red-0)\"],\"duration\":[1200,1800],\"easing\":\"easeOutExpo\",\"move\":[\"diffuse\"],\"number\":1,\"shape\":\"polygon\",\"shapeOptions\":{\"alpha\":[0.2,0.5],\"lineWidth\":6,\"radius\":20,\"sides\":3}}]}");
        options.excludeElements = options.excludeelements;
        delete options.excludeelements;
        window.firework(options);
      }
    }
  }
</script><script
    src="https://npm.webcache.cn/mouse-firework@0.2.0/dist/index.umd.js"
    defer
    
    
    onload="setupFirework()"
    integrity="sha384-qi9WggRt19tv8Vc7pCHW3ulMNLwrn515zaLEWZjl1px07vz8&#43;pUoWX8n1rgq282T" crossorigin="anonymous"></script>

<div id="lazy-script">
  <div><script data-pjax>
        window.REIMU_POST = {
          author: "PrincessSarmica",
          title: "Uvod v računalniški vid in razpoznavanje vzorcev",
          url: "https:\/\/example.org\/post\/urvrv\/",
          description: "Zapiski za predmet Uvod v računalniški vid in razpoznavanje vzorcev za zimski semester tretjega letnika FERI RIT UNI, ki zajemajo osnovne koncepte računalniškega vida, obdelavo slik, prepoznavanje vzorcev ter uvod v strojno učenje za analizo vizualnih podatkov.",
          cover: "https:\/\/example.org\/images\/banner.webp",
        };
      </script><script src="/js/insert_highlight.js" integrity="" crossorigin="anonymous" data-pjax ></script><script src="/js/tabs.js" integrity="" crossorigin="anonymous" data-pjax defer></script><script type="module" data-pjax>const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;const initPswp = (gallery, children) => {
          if (_$$(`${gallery} ${children}`).length > 0) {
            new PhotoSwipeLightbox({
              gallery,
              children,pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")}).init();
          }
        }
        const pswp = () => {
          initPswp('.article-entry', 'a.article-gallery-item');
          initPswp('.article-gallery', 'a.article-gallery-item');
        }
        pswp()
      </script><script
    src="https://npm.webcache.cn/katex@0.16.24/dist/katex.min.js"
    
    
    data-pjax
    
    integrity="sha384-MWNUH0WmtsYGhn2cbH6ELRCbf9LG3QDqCC&#43;gqPB3IBNO35xjZK3Ejb6oONRpDbPg" crossorigin="anonymous"></script><script
    src="https://npm.webcache.cn/katex@0.16.24/dist/contrib/auto-render.min.js"
    
    
    data-pjax
    
    integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv&#43;fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script><script data-pjax>
          var renderMath = () => {
            if (!window.renderMathInElement) return;
            window.renderMathInElement(_$("article"), {
              delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
              ],
            });
          };
          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", renderMath, { once: true });
          } else {
            renderMath();
          }
        </script></div>
</div><script
    src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js"
    
    async
    
    
    integrity="sha384-0M75wtSkhjIInv4coYlaJU83&#43;OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id&#43;S" crossorigin="anonymous"></script><script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((registrations) => {
        for (let registration of registrations) {
          registration.unregister();
        }
      });
    }
  </script><script>
  const reimuCopyright = String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;
  console.log(String.raw`%c ${reimuCopyright}`, "color: #ff5252;");
  console.log(
    "%c Theme.Reimu" + " %c https://github.com/D-Sketon/hugo-theme-reimu ",
    "color: white; background: #ff5252; padding:5px 0;",
    "padding:4px;border:1px solid #ff5252;",
  );
</script></body>
</html>
